@require: test/test
@require: test/expect

@import: ../src/char
@import: ../src/eq
@import: ../src/list-ext
@import: ../src/ord
@import: ../src/string

let string-test-cases = open Test in
    describe `String module` [
    it `check equality of strings` (fun () -> (
      Eq.equal String.eq `abc` `abc`
      && not Eq.equal String.eq `abc` `abd`
      |> Expect.is-true
    ));
    it `concatenate strings` (fun () -> (
      String.concat [`a`; `b`; `c`]
      |> string-same `abc`
      |> Expect.is-true
    ));
    it `check emptiness of string` (fun () -> (
      String.is-empty ` `
      && (not String.is-empty `hi`)
      |> Expect.is-true
    ));
    it `split string with a given delimiter` (fun () -> (
      let delimiter = Char.make `;` in
      `spam;ham;eggs;`
      |> String.split-by delimiter
      |> Eq.equal (List.eq String.eq) [`spam`; `ham`; `eggs`; ` `]
      |> Expect.is-true
    ));
    it `convert a string to a list of characters` (fun () -> (
      let expected = [
        Char.make `a`;
        Char.make `b`;
        Char.make `c`;
      ] in
      String.to-list `abc`
      |> Eq.equal (List.eq Char.eq) expected
      |> Expect.is-true
    ));
    it `compare strings with lexicographical order` (fun () -> (
      let subject = Ord.compare String.ord in
      [
        subject `a` `a`;
        subject `a` `b`;
        subject `ab` `ba`;
        subject `aab` `aba`;
        subject `bbb` `bbba`;
      ] |> Eq.equal (List.eq Ordering.eq) [
        Eq; Lt; Lt; Lt; Lt;
      ] |> Expect.is-true
    ));
    % TODO
    % * sub
    % * of-bool
    % * of-int
    % * of-float
    % * of-codepoints
    % * of-char
    % * of-length
    % * append
    % * starts-with
    % * ends-with
    % * of-list
    % * pow
    % * split
    % * split-by-first
    % * lines
    % * index
  ]

