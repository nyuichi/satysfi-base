use Promise
use open Util
use Option
use List
use Tuple
use Result
use String
use Array

module Stream :> sig
  type t :: o -> o
  val persistent ~nil : unit -> t 'a
  val persistent ~cons : thunk 'a -> thunk (t 'a) -> t 'a
  val persistent ~unfold : ('a -> option ('b * 'a)) -> 'a -> t 'b
  val persistent ~const : 'a -> t 'a
  val persistent ~nat : int t
  val persistent ~fib : int t
  val persistent ~uncons : t 'a -> option ('a * t 'a)
  val persistent ~null : t 'a -> bool
  val persistent ~head : t 'a -> option 'a
  val persistent ~tail : t 'a -> option (t 'a)
  val persistent ~length : t 'a -> int
  val persistent ~last : t 'a -> option 'a
  val persistent ~nth : int -> t 'a -> option 'a
  val persistent ~step-by : int -> t 'a -> t 'a
  val persistent ~append : t 'a -> t 'a -> t 'a
  val persistent ~chain : t 'a -> t 'a -> t 'a
  val persistent ~zip : t 'a -> t 'b -> t ('a * 'b)
  val persistent ~map : ('a -> 'b) -> t 'a -> t 'b
  val persistent ~iter : ('a -> unit) -> t 'a -> unit
  val persistent ~filter : ('a -> bool) -> t 'a -> t 'a
  val persistent ~filter-map : ('a -> option 'b) -> t 'a -> t 'b
  val persistent ~enumerate : t 'a -> t (int * 'a)
  val persistent ~drop-while : ('a -> bool) -> t 'a -> t 'a
  val persistent ~take-while : ('a -> bool) -> t 'a -> t 'a
  val persistent ~map-while : ('a -> option 'b) -> t 'a -> t 'b
  val persistent ~drop : int -> t 'a -> t 'a
  val persistent ~take : int -> t 'a -> t 'a
  val persistent ~flat-map : ('a -> t 'b) -> t 'a -> t 'b
  val persistent ~flatten : t (t 'a) -> t 'a
  val persistent ~tap : ('a -> unit) -> t 'a -> t 'a
  val persistent ~partition : ('a -> bool) -> t 'a -> (t 'a * t 'a)
  val persistent ~fold-option : 'b -> ('a -> 'b -> option 'b) -> t 'a -> option 'b
  val persistent ~fold-result : 'b -> ('a -> 'b -> result 'b 'e) -> t 'a -> result 'b 'e
  val persistent ~iter-option : ('a -> option unit) -> t 'a -> option unit
  val persistent ~iter-result : ('a -> result unit 'e) -> t 'a -> result unit 'e
  val persistent ~all : ('a -> bool) -> t 'a -> bool
  val persistent ~any : ('a -> bool) -> t 'a -> bool
  val persistent ~find : ('a -> bool) -> t 'a -> option 'a
  val persistent ~find-map : ('a -> option 'b) -> t 'a -> option 'b
  val persistent ~find-result : ('a -> result bool 'e) -> t 'a -> result (option 'a) 'e
  val persistent ~position : ('a -> bool) -> t 'a -> int option
  val persistent ~unzip : t ('a * 'b) -> (t 'a * t 'b)
  val persistent ~of-list : list 'a -> t 'a
  val persistent ~of-string : string -> t Char.t
  val persistent ~of-array : Array.t 'a -> t 'a
  val persistent ~of-option : option 'a -> t 'a
  val persistent ~to-list : t 'a -> list 'a
  val persistent ~to-array : t 'a -> Array.t 'a

  % deprecated
  val persistent ~fold : ('b -> 'a -> 'b) -> 'b -> t 'a -> 'b  % TODO: swap arguments
end = struct

  type state 'a =
  | Nil
  | Cons of 'a * t 'a
  and t 'a = Promise.t (state 'a)

  val persistent ~nil () =
    Promise.make Nil

  val persistent ~cons x xs =
    Promise.delay (fun () -> Cons (run-thunk x, run-thunk xs))

  val persistent ~uncons s =
    match Promise.force s with
    | Nil -> Option.none
    | Cons(x, s) -> Option.some (x, s)
    end

  val persistent ~head s =
    uncons s |> Option.map Pair.fst

  val persistent ~tail s =
    uncons s |> Option.map Pair.snd

  val persistent ~rec unfold f x =
    Promise.delay-force
      (fun () -> (
        match f x with
        | None -> nil ()
        | Some(a, x) -> cons (fun () -> a) (fun () -> unfold f x)
        end
      ))

  val persistent ~map f s =
    let go s =
      match uncons s with
      | None -> Option.none
      | Some(x, s) -> Option.some (f x, s)
      end
    in
      s |> unfold go

  val persistent ~filter f s =
    let rec go s =
      match uncons s with
      | None -> Option.none
      | Some(x, s) ->
        if f x then
          Option.some (x, s)
        else
          go s
      end
    in
      s |> unfold go

  val persistent ~zip s1 s2 =
    let go (s1, s2) =
      match (uncons s1, uncons s2) with
      | (None, _) -> Option.none
      | (_, None) -> Option.none
      | (Some(x1, s1), Some(x2, s2)) -> Option.some ((x1, x2), (s1, s2))
      end
    in
      (s1, s2) |> unfold go

  val persistent ~rec unzip s =
    (map Pair.fst s, map Pair.snd s)

  val persistent ~rec take n s =
    Promise.delay-force
      (fun () -> (
        if n == 0 then
          nil ()
        else
          match uncons s with
          | None -> nil ()
          | Some(x, xs) -> cons (fun () -> x) (fun () -> take (n - 1) xs)
          end
      ))

  val persistent ~rec drop n s =
    Promise.delay-force
      (fun () -> (
        if n == 0 then
          s
        else
          match uncons s with
          | None -> nil ()
          | Some(x, xs) -> drop (n - 1) xs
          end
      ))

  val persistent ~rec to-list s =
    match uncons s with
    | None -> []
    | Some(x, xs) ->
      x :: to-list xs
    end

  val persistent ~of-list xs =
    xs |> unfold List.uncons

  val persistent ~fold f x s =
    let rec aux x s =
      match uncons s with
      | None -> x
      | Some(a, s) ->
        aux (f x a) s
      end
    in aux x s

  val persistent ~fib =
    let rec fib n m =
      cons (fun () -> n) (fun () -> fib m (n + m))
    in fib 1 1

  val persistent ~nat =
    let rec nat n =
      cons (fun () -> n) (fun () -> nat (n + 1))
    in nat 0

  val persistent ~rec const x =
    cons (fun () -> x) (fun () -> const x)

  val persistent ~null s =
    s |> uncons |> Option.is-none

  val persistent ~length s =
    let rec go i s =
      match uncons s with
      | None -> i
      | Some(_, s) -> go (i + 1) s
      end
    in
      go 0 s

  val persistent ~last s =
    let rec go x s =
      match uncons s with
      | None -> x
      | Some(x, s) -> go (Option.some x) s
      end
    in
      go Option.none s

  val persistent ~nth n s =
    let rec go i s =
      match uncons s with
      | None -> Option.none
      | Some(x, s) ->
        if i == 0 then
          Option.some x
        else
          go (i - 1) s
      end
    in
      go n s

  val persistent ~enumerate s =
    zip nat s

  val persistent ~step-by n s =
    if n == 0 then
      panic `Stream.step-by: invalid argument`
    else
      s |> enumerate |> filter (fun (i, x) -> i mod n == 0) |> map Pair.snd

  val persistent ~rec chain s2 s1 =
    Promise.delay-force
      (fun () -> (
        match uncons s1 with
        | None -> s2
        | Some(x, s1) -> cons (fun () -> x) (fun () -> chain s1 s2)
        end
      ))

  val persistent ~append s1 s2 =
    s1 |> chain s2

  val persistent ~iter f s =
    let rec go s =
      match uncons s with
      | None -> ()
      | Some(x, s) -> f x before go s
      end
    in
      go s

  val persistent ~filter-map f s =
    s |> map f |> filter Option.is-some |> map Option.unwrap

  val persistent ~drop-while f s =
    let rec go s =
      match uncons s with
      | None -> nil ()
      | Some(x, s0) -> if not (f x) then s else go s0
      end
    in
      Promise.delay-force (fun () -> go s)

  val persistent ~rec take-while f s =
    Promise.delay-force
      (fun () -> (
        match uncons s with
        | None -> nil ()
        | Some(x, s) ->
            if f x then
              cons (fun () -> x) (fun () -> take-while f s)
            else
              nil ()
        end
      ))

  val persistent ~map-while f s =
    s |> map f |> take-while Option.is-some |> map Option.unwrap

  val persistent ~rec flatten s =
    Promise.delay-force
      (fun () -> (
        match uncons s with
        | None -> nil ()
        | Some(x, s) -> append x (flatten s)
        end
      ))

  val persistent ~flat-map f s =
    s |> map f |> flatten

  val persistent ~tap f s =
    s |> map (fun x -> (f x before x))

  val persistent ~partition f s =
    (s |> filter f, s |> filter (Fn.non f))

  val persistent ~fold-option x f s =
    let rec go s x =
      match uncons s with
      | None -> x |> Option.ret
      | Some(y, s) -> x |> f y |> Option.and-then (go s)
      end
    in
      go s x

  val persistent ~fold-result x f s =
    let rec go s x =
      match uncons s with
      | None -> x |> Result.ret
      | Some(y, s) -> x |> f y |> Result.and-then (go s)
      end
    in
      go s x

  val persistent ~iter-option f s =
    let rec go s =
      match uncons s with
      | None -> () |> Option.ret
      | Some(x, s) -> x |> f |> Option.and-then (fun () -> go s)
      end
    in
      go s

  val persistent ~iter-result f s =
    let rec go s =
      match uncons s with
      | None -> Result.ret ()
      | Some(x, s) -> f x |> Result.and-then (fun () -> go s)
      end
    in
      go s

  val persistent ~find f s =
    s |> fold-result () (fun x () -> (
      if f x then
        Result.err x
      else
        Result.ok ()
      ))
      |> Result.to-err

  val persistent ~all f s =
    s |> map f |> find (fun b -> not b) |> Option.is-none

  val persistent ~any f s =
    s |> map f |> find (fun b -> b) |> Option.is-some

  val persistent ~find-map f s =
    s |> filter-map f |> head

  val persistent ~find-result f s =
    s |> fold-result () (fun x () -> (
      f x
        |> Result.map-err Result.err
        |> Result.and-then (fun b -> (
          if b then
            Result.err (Result.ok x)
          else
            Result.ok ()
        ))
      ))
      |> Result.to-err
      |> Option.transpose

  val persistent ~position f s =
    s |> enumerate |> find (Fn.compose f Pair.snd) |> Option.map Pair.fst

  val persistent ~of-string s =
    of-list (String.to-list s)

  val persistent ~of-array s =
    let len = Array.length s in
    let step i =
      if i == len then
        Option.none
      else
        Option.some (Array.get i s, i + 1)
    in
      0 |> unfold step

  val persistent ~of-option opt =
    let go opt =
      opt |> Option.map (fun x -> (x, Option.none))
    in
      opt |> unfold go

  val persistent ~to-array s =
    match uncons s with
    | None -> Array.of-list []
    | Some(x, _) ->
      let result = Array.make x (s |> length) in
      s |> enumerate
        |> iter (fun (i, a) -> (
          result |> Array.set i a
        )) before
      result
    end
end
