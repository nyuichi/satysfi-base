use Util
use Ord
use TreeSet
use Option
use Int
use Stream
use Tuple

module TreeMap :> sig
  %% Immutable map.
  type t :: o -> o -> o

  %% Creates an empty map.
  val persistent ~empty : t 'k 'v

  %% Returns the number of elements in the given map.
  val persistent ~size : t 'k 'v -> int

  %% Returns [true] if the given map is empty.
  val persistent ~is-empty : t 'k 'v -> bool

  %% Returns [true] if the given map contains a binding to the given key.
  val persistent ~contains : implicit (Ord.t 'k) -> 'k -> t 'k 'v -> bool

  %% [get ord k m] returns the value bound to [k].
  val persistent ~get : implicit (Ord.t 'k) -> 'k -> t 'k 'v -> option 'v

  %% Binds key to the value.
  val persistent ~insert : implicit (Ord.t 'k) -> 'k -> 'v -> t 'k 'v -> t 'k 'v

  %% Removes a binding from the given map.
  val persistent ~remove : implicit (Ord.t 'k) -> 'k -> t 'k 'v -> t 'k 'v

  %% Constructs a map from a list. If the list contains two equal keys, the preceding one is preferred.
  val persistent ~of-list : implicit (Ord.t 'k) -> list ('k * 'v) -> t 'k 'v

  val persistent ~to-list : t 'k 'v -> list ('k * 'v)

  val persistent ~to-stream : t 'k 'v -> Stream.t ('k * 'v)
end = struct

  type t 'k 'v = TreeSet.t ('k * (option 'v))

  val persistent ~empty = TreeSet.empty

  val persistent ~size = TreeSet.size

  val persistent ~is-empty = TreeSet.is-empty

  val persistent ~key-ord ord = Ord.make (fun (k1, _) (k2, _) -> Ord.compare ord k1 k2)

  val persistent ~get ord key map =
    map |> TreeSet.get (key-ord ord) (key, None) |> Option.map (Fn.compose Option.unwrap Pair.snd)

  val persistent ~contains ord key map =
    Option.is-some (get ord key map)

  val persistent ~insert ord key value map =
    map |> TreeSet.insert (key-ord ord) (key, Some(value))

  val persistent ~remove ord key map =
    map |> TreeSet.remove (key-ord ord) (key, None)

  val persistent ~of-list ord list =
    list |> List.map (fun (k, v) -> (k, Some(v))) |> TreeSet.of-list (key-ord ord)

  val persistent ~to-stream map =
    map |> TreeSet.to-stream |> Stream.map (fun (k, v) -> (k, Option.unwrap v))

  val persistent ~to-list map =
    map |> to-stream |> Stream.to-list

end
