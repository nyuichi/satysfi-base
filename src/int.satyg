use open Util
use Ord
use Eq
use String
use Char
use List
use Option

module Int :> sig
  val persistent ~ord : implicit (Ord.t int)
  val persistent ~eq : implicit (Eq.t int)

  val persistent ~equal : int -> int -> bool

  val persistent ~bitsize : int
  val persistent ~max-value : int
  val persistent ~min-value : int

  val persistent ~(<) : int -> int -> bool
  val persistent ~(>) : int -> int -> bool
  val persistent ~(>=) : int -> int -> bool
  val persistent ~(<=) : int -> int -> bool
  val persistent ~(==) : int -> int -> bool

  val persistent ~succ : int -> int
  val persistent ~pred : int -> int
  val persistent ~neg : int -> int
  val persistent ~add : int -> int -> int
  val persistent ~sub : int -> int -> int
  val persistent ~mul : int -> int -> int
  val persistent ~div : int -> int -> int
  val persistent ~abs : int -> int
  val persistent ~pow : int -> int -> int
  val persistent ~max : int -> int -> int
  val persistent ~min : int -> int -> int
  val persistent ~sup : list int -> int
  val persistent ~inf : list int -> int

  % bitwise operations
  val persistent ~lsl : int -> int -> int
  val persistent ~asr : int -> int -> int
  val persistent ~lsr : int -> int -> int
  val persistent ~lnot : int -> int
  val persistent ~land : int -> int -> int
  val persistent ~lor : int -> int -> int
  val persistent ~lxor : int -> int -> int

  val persistent ~of-string : ?(radix : int) string -> int % may throw an error
  val persistent ~to-string : int -> string
  val persistent ~of-string-opt : ?(radix : int) string -> option int
end = struct
  val persistent ~ord = Ord.make (fun i j -> (if i == j then Ord.Eq else if i < j then Ord.Lt else Ord.Gt))
  val persistent ~max = Ord.max ord
  val persistent ~min = Ord.min ord

  val persistent ~eq = Ord.derive-eq ord
  val persistent ~equal = Eq.equal eq

  val persistent ~(<) = (<)
  val persistent ~(>) = (>)
  val persistent ~(>=) = (>=)
  val persistent ~(<=) = (<=)
  val persistent ~(==) = (==)

  val persistent ~add i j = i + j
  val persistent ~sub i j = i - j
  val persistent ~mul i j = i * j
  val persistent ~div i j = i / j

  val persistent ~succ i = i + 1
  val persistent ~pred i = i - 1
  val persistent ~neg i = -i
  val persistent ~abs i = if i < 0 then -i else i
  val persistent ~pow p base = % REQUIRE(p >= 0)
    let rec aux p pp acc =
      if p == 0 then
        acc
      else if p mod 2 == 1 then
        aux (p / 2) (pp * pp) (acc * pp)
      else
        aux (p / 2) (pp * pp) acc
    in aux p base 1
  val persistent ~bitsize = 63 % assume 64-bit machine
  val persistent ~max-value = (2 |> pow (bitsize - 1)) - 1
  val persistent ~min-value = max-value + 1
  val persistent ~rec sup xs0 =
    match xs0 with
    | [] -> min-value
    | x :: xs -> max x (sup xs)
    end
  val persistent ~rec inf xs0 =
    match xs0 with
    | [] -> max-value
    | x :: xs -> min x (inf xs)
    end

  val persistent ~lnot i = (-i) - 1

  val persistent ~rec lsl shift i = i * pow shift 2
  val persistent ~rec asr shift i =
    if i >= 0 then
      i / pow shift 2
    else
      lnot (asr shift (lnot i))

  val persistent ~bitwise-op op i j =
    let rec aux n i j =
      if n == 0 then
        0
      else
        (aux (n - 1) (i |> asr 1) (j |> asr 1)) * 2 + op (abs (i mod 2)) (abs (j mod 2))
    in aux bitsize i j

  val persistent ~land = bitwise-op (fun i j -> i * j)
  val persistent ~lxor = bitwise-op (fun i j -> (i + j) mod 2)
  val persistent ~lor = bitwise-op (fun i j -> 1 - (1 - i) * (1 - j))

  val persistent ~lsr shift i =
    if i >= 0 then
      asr shift i
    else
      i |> asr shift |> land ((2 |> pow (bitsize - shift)) - 1)

  val persistent ~char-to-int c =
    let digit = `0123456789` in
    let loweralpha = `abcdefghijklmnopqrstuvwxyz` in
    let upperalpha = `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in
    match String.index c digit with
    | Some(i) -> Some(i)
    | None ->
      match String.index c upperalpha with
      | Some(i) -> Some(i + 10)
      | None ->
        match String.index c loweralpha with
        | Some(i) -> Some(i + 10)
        | None -> None
        end
      end
    end


  val persistent ~to-string = arabic
  val persistent ~of-string-opt ?(radix = radix-opt) s =
    let radix =
      match radix-opt with
      | None -> 10
      | Some(i) -> i
      end
    in
    let cs = String.to-list s in
    match cs with
    | [] -> None
    | c::cs2 ->
      let (sign, cs) = if Eq.equal Char.eq c (Char.make `-`) then (-1, cs2) else (1, cs) in
      let num-opt = cs |> List.fold-left (fun acc-opt c -> (
        match acc-opt with
        | None -> Option.none
        | Some(acc) ->
          match char-to-int c with
          | None -> Option.none
          | Some(i) ->
            if i < radix then
              Option.some (acc * radix + i)
            else
              Option.none
          end
        end)) (Option.some 0) in
      match num-opt with
      | None -> Option.none
      | Some(num) -> Option.some (sign * num)
      end
    end

  val persistent ~of-string ?(radix = radix-opt) s =
    let msg = `Int.of-string: invalid string: `# ^ s in
    match radix-opt with
    | None -> of-string-opt s |> Option.expect msg
    | Some(radix) -> of-string-opt ?(radix = radix) s |> Option.expect msg
    end


end
