use open Util
use List
use Option
use String
use Tuple
use Char
use Fn
use Result
use Ord
use Int
use Ref
use Promise
use Stream
use Token

module Parser :> sig
  type parse-error 'd = (|
    token : option (Token.t 'd),  % None for EOF
    desc  : string,
  |)

  type t :: o -> o -> o

  val persistent ~run 'a 'd : t 'a 'd -> Stream.t (Token.t 'd) -> result 'a (list (parse-error 'd))

  % functor
  val persistent ~map 'a 'b 'd : ('a -> 'b) -> t 'a 'd -> t 'b 'd
  val persistent ~(<&>) 'a 'b 'd : t 'a 'd -> ('a -> 'b) -> t 'b 'd

  % applicative
  val persistent ~pure 'a 'd : 'a -> t 'a 'd
  val persistent ~ap 'a 'b 'd : t 'a 'd -> t ('a -> 'b) 'd -> t 'b 'd
  val persistent ~(<*>) 'a 'b 'd : t ('a -> 'b) 'd -> t 'a 'd -> t 'b 'd
  val persistent ~(*>) 'a 'b 'd : t 'a 'd -> t 'b 'd -> t 'b 'd
  val persistent ~(<*) 'a 'b 'd : t 'a 'd -> t 'b 'd -> t 'a 'd
  val persistent ~traverse 'a 'b 'd : ('a -> t 'b 'd) -> list 'a -> t (list 'b) 'd
  val persistent ~sequence 'a 'd : list (t 'a 'd) -> t (list 'a) 'd

  % monad
  val persistent ~ret 'a 'd : 'a -> t 'a 'd
  val persistent ~bind 'a 'b 'd : ('a -> t 'b 'd) -> t 'a 'd -> t 'b 'd
  val persistent ~(>>=) 'a 'b 'd : t 'a 'd -> ('a -> t 'b 'd) -> t 'b 'd
  val persistent ~(>>) 'a 'b 'd : t 'a 'd -> t 'b 'd -> t 'b 'd
  val persistent ~(<<) 'a 'b 'd : t 'a 'd -> t 'b 'd -> t 'a 'd

  % alternative
  val persistent ~empty 'a 'd : t 'a 'd
  val persistent ~alt 'a 'd : t 'a 'd -> t 'a 'd -> t 'a 'd   % predicative choice; the second parser is only tried when the first parser fails without consuming any tokens
  val persistent ~(<|>) 'a 'd : t 'a 'd -> t 'a 'd -> t 'a 'd
  val persistent ~some 'a 'd : t 'a 'd -> t (list 'a) 'd  % one or more; use `try` if necessary
  val persistent ~many 'a 'd : t 'a 'd -> t (list 'a) 'd  % zero or more; use `try` if necessary
  val persistent ~optional 'a 'd : t 'a 'd -> t (option 'a) 'd  % zero or one; use `try` if necessary
  val persistent ~choice 'a 'd : list (t 'a 'd) -> t 'a 'd  % use `try` if necessary

  % error handling
  val persistent ~report 'd : string -> t unit 'd  % reports new error messege; always succeeds and never consumes input
  val persistent ~label 'a 'd : string -> t 'a 'd -> t 'a 'd  % reports new error message on failure of the given parser regardless of consumption of input
  val persistent ~(<?>) 'a 'd : t 'a 'd -> string -> t 'a 'd
  val persistent ~fail 'a 'd : string -> t 'a 'd

  % parser
  val persistent ~try 'a 'd : t 'a 'd -> t 'a 'd  % mark savepoints to perform backtracking
  val persistent ~lookahead 'a 'd : t 'a 'd -> t 'a 'd
  val persistent ~not-followed-by 'a 'd : t 'a 'd -> t unit 'd  % flip success and failure; never consumes input
  val persistent ~catch 'a 'd : t 'a 'd -> t (option 'a * list (parse-error 'd)) 'd
  val persistent ~any 'd : t (Token.t 'd) 'd

  % recursively defined grammars
  val persistent ~delay 'a 'd : Promise.t (t 'a 'd) -> t 'a 'd
  val persistent ~fix 'a 'd : (t 'a 'd -> t 'a 'd) -> t 'a 'd

  % derived combinators
  val persistent ~eof 'd : t unit 'd
  val persistent ~satisfy 'd : (Token.t 'd -> bool) -> t (Token.t 'd) 'd
  val persistent ~some-sep-by 'sep 'a 'd : t 'sep 'd -> t 'a 'd -> t (list 'a) 'd
  val persistent ~many-sep-by 'sep 'a 'd : t 'sep 'd -> t 'a 'd -> t (list 'a) 'd
  val persistent ~between 'open 'close 'a 'd : t 'open 'd -> t 'close 'd -> t 'a 'd -> t 'a 'd
  val persistent ~pair 'a 'b 'd : t 'a 'd -> t 'b 'd -> t ('a * 'b) 'd
  val persistent ~triple 'a 'b 'c 'd : t 'a 'd -> t 'b 'd -> t 'c 'd -> t ('a * 'b * 'c) 'd
  val persistent ~some-chain-left 'a 'd : t ('a -> 'a -> 'a) 'd -> t 'a 'd -> t 'a 'd
end = struct

  type parse-error 'd = (|
    token : option (Token.t 'd),  % None for EOF
    desc  : string,
  |)

  % state of parser
  type state 'd = (|
    input : Stream.t (Token.t 'd),
  |)

  % indicates whether backtracking is to be performed on failure; see `alt`
  type consumption = Consumed | Virgin

  val persistent ~(<+>) c1 c2 =
    match (c1, c2) with
    | (Virgin, Virgin) -> Virgin
    | _ -> Consumed
    end

  % (Some a, _, []) -> parsing success with result a
  % (Some a, _, es) -> parsing continued while some errors were found and recovered (e.g. parsing continues after missing `}`)
  type t 'a 'd = state 'd -> option (state 'd * 'a) * consumption * list (parse-error 'd)

  val persistent ~run p s =
    let initial-state = (| input = s |) in
    match p initial-state with
    | (Some (_, a), _, []) ->
      Result.ok a
    | (_, _, es) ->
      Result.err es
    end

  val persistent ~delay t =
    fun state -> (Promise.force t) state

  val persistent ~map f p s =
    match p s with
    | (Some (s, a), c, es) ->
      (Option.some (s, f a), c, es)
    | (None, c, es) ->
      (Option.none, c, es)
    end

  val persistent ~(<&>) p f = map f p

  val persistent ~ret a s =
    (Option.some (s, a), Virgin, [])

  val persistent ~bind k p s =
    match p s with
    | (Some (s, a), c1, e1) ->
      match (k a) s with
      | (Some (s, b), c2, e2) ->
        (Option.some (s, b), c1 <+> c2, List.append e2 e1)
      | (None, c2, e2) ->
        (Option.none, c1 <+> c2, List.append e2 e1)
      end
    | (None, c1, e1) ->
      (Option.none, c1, e1)
    end

  val persistent ~(>>=) p f = bind f p
  val persistent ~(>>) p1 p2 = p1 >>= (fun _ -> p2)
  val persistent ~(<<) p1 p2 = p1 >>= (fun x -> (p2 >> ret x))

  val persistent ~pure = ret
  val persistent ~ap p1 p2 = p2 >>= (fun f -> p1 >>= (fun x -> ret (f x)))
  val persistent ~(<*>) p1 p2 = ap p2 p1
  val persistent ~(*>) = (>>)
  val persistent ~(<*) = (<<)

  val persistent ~traverse f xs =
    let rec aux xs =
      match xs with
      | [] -> pure []
      | x :: xs -> (pure List.cons <*> f x) <*> aux xs
      end
    in aux xs

  val persistent ~sequence xs =
    traverse Fn.id xs

  val persistent ~empty s =
    (Option.none, Virgin, [])

  val persistent ~alt p1 p2 s =
    match p1 s with
    | (None, Virgin, e1) ->
      match p2 s with
      | (None, c, e2) -> (Option.none, c, List.append e2 e1)
      | r -> r
      end
    | r -> r
    end

  val persistent ~(<|>) = alt

  val persistent ~rec
    many p = some p <|> pure []
  and
    some p = p >>= (fun x -> many p >>= (fun xs -> ret (x :: xs)))

  val persistent ~optional p = (pure Option.some <*> p) <|> pure Option.none

  val persistent ~choice ps =
    List.fold-right alt empty ps

  % private API; impredictive choice a la PEG
  val persistent ~(</>) p1 p2 s =
    match p1 s with
    | (None, c1, e1) ->
      let (o, c2, e2) = p2 s in
      (o, c2 <+> c1, List.append e2 e1)
    | r -> r
    end

  val persistent ~make-error s desc =
    (| token = Stream.head s#input, desc = desc |)

  val persistent ~report desc s =
    (Option.some (s, ()), Virgin, [make-error s desc])

  val persistent ~label desc p =
    p </> (report desc >> empty)

  val persistent ~(<?>) p desc = label desc p

  val persistent ~fail desc =
    empty <?> desc

  val persistent ~try p s =
    match p s with
    | (None, _, e) ->
      (Option.none, Virgin, e)
    | r -> r
    end

  val persistent ~lookahead p s =
    match p s with
    | (Some (s, a), _, e) ->
      (Option.some (s, a), Virgin, e)
    | r -> r
    end

  val persistent ~not-followed-by p s =
    match p s with
    | (None, _, _) ->
      (Option.some (s, ()), Virgin, [])
    | _ ->
      (Option.none, Virgin, [])
    end

  val persistent ~catch p s =
    let (o, _, e) = p s in
    (Option.some (s, (o |> Option.map Tuple.Pair.snd, e)), Virgin, [])

  val persistent ~any s =
    match Stream.uncons s#input with
    | None ->
      (Option.none, Virgin, [])
    | Some(t, new-input) ->
      (Option.some ((| input = new-input |), t), Consumed, [])
    end

  % derived combinators

  val persistent ~eof state =
    (not-followed-by any) state

  val persistent ~satisfy pred =
    try (any >>= (fun t -> (
      if pred t then
        ret t
      else
        empty
    )))

  val persistent ~some-sep-by sep p =
    p >>= (fun x -> many (try (sep >> p)) >>= (fun xs -> ret (x :: xs)))

  val persistent ~many-sep-by sep p = try (some-sep-by sep p) <|> ret []

  val persistent ~between op cl p =
    op >> p >>= (fun x -> cl >> ret x)

  val persistent ~pair p1 p2 =
    (pure Tuple.Pair.make <*> p1) <*> p2

  val persistent ~triple p1 p2 p3 =
    p1 >>= (fun x -> p2 >>= (fun y -> p3 >>= (fun z -> ret (x, y, z))))

  val persistent ~chain-left op a p =
    many (pair op p) |> map (List.fold-left (fun a (op, b) -> op a b) a)

  val persistent ~some-chain-left op p =
    p >>= (fun x -> p |> chain-left op x)

  val persistent ~fix f =
    let stash = Ref.make empty in
    let main = delay (Promise.delay (fun () -> (!stash))) in
    let () = stash |> Ref.set (f main) in
    main

end
