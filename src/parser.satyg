use List
use Option
use String
use Char
use Fn
use Result
use Ord
use Int
use Promise
use Stream
use Token

module Parser :> sig
  type parse-error 'd = (|
    token : option (Token.t 'd),  % None for EOF
    desc  : string,
  |)

  type t :: o -> o -> o

  val run : t 'a 'd -> Stream.t (Token.t 'd) -> result 'a (list (parse-error 'd))

  % functor
  val map 'a 'b 'd : ('a -> 'b) -> t 'a 'd -> t 'b 'd
  val (<&>) 'a 'b 'd : t 'a 'd -> ('a -> 'b) -> t 'b 'd

  % applicative
  val pure 'a 'd : 'a -> t 'a 'd
  val ap 'a 'b 'd : t 'a 'd -> t ('a -> 'b) 'd -> t 'b 'd
  val (<*>) 'a 'b 'd : t ('a -> 'b) 'd -> t 'a 'd -> t 'b 'd
  val (*>) 'a 'b 'd : t 'a 'd -> t 'b 'd -> t 'b 'd
  val (<*) 'a 'b 'd : t 'a 'd -> t 'b 'd -> t 'a 'd
  val traverse 'a 'b : ('a -> t 'b 'd) -> list 'a -> t (list 'b) 'd
  val sequence 'a 'd : list (t 'a 'd) -> t (list 'a) 'd

  % monad
  val ret : 'a -> t 'a 'd
  val bind : ('a -> t 'b 'd) -> t 'a 'd -> t 'b 'd
  val (>>=) : t 'a 'd -> ('a -> t 'b 'd) -> t 'b 'd
  val (>>) : t 'a 'd -> t 'b 'd -> t 'b 'd
  val (<<) : t 'a 'd -> t 'b 'd -> t 'a 'd

  % alternative
  val empty 'a 'd : t 'a 'd
  val alt 'a 'd : t 'a 'd -> t 'a 'd -> t 'a 'd   % predicative choice; the second parser is only tried when the first parser fails without consuming any tokens
  val (<|>) 'a 'd : t 'a 'd -> t 'a 'd -> t 'a 'd
  val some 'a 'd : t 'a 'd -> t (list 'a) 'd  % one or more; use `try` if necessary
  val many 'a 'd : t 'a 'd -> t (list 'a) 'd  % zero or more; use `try` if necessary
  val optional 'a 'd : t 'a 'd -> t (option 'a) 'd  % zero or one; use `try` if necessary
  val choice 'a 'd : list (t 'a 'd) -> t 'a 'd  % use `try` if necessary

  % error handling
  val report 'd : string -> unit 'd t  % reports new error messege; always succeeds and never consumes input
  val label 'a 'd : string -> t 'a 'd -> t 'a 'd  % reports new error message on failure of the given parser regardless of consumption of input
  val (<?>) 'a 'd : t 'a 'd -> string -> t 'a 'd
  val fail 'a 'd : string -> t 'a 'd

  % parser
  val try 'a 'd : t 'a 'd -> t 'a 'd  % mark savepoints to perform backtracking
  val lookahead 'a 'd : t 'a 'd -> t 'a 'd
  val not-followed-by 'a 'd : t 'a 'd -> unit 'd t  % flip success and failure; never consumes input
  val catch 'a 'd : t 'a 'd -> t (option 'a * list (parse-error 'd)) 'd
  val any 'd : t (Token.t 'd) 'd

  % recursively defined grammars
  val delay 'a 'd : Promise.t (t 'a 'd) -> t 'a 'd
  val fix 'a 'd : (t 'a 'd -> t 'a 'd) -> t 'a 'd

  % derived combinators
  val eof 'd : t unit 'd
  val satisfy 'd : (Token.t 'd -> bool) -> t (Token.t 'd) 'd
  val some-sep-by 'a 'd : t 'sep 'd -> t 'a 'd -> t (list 'a) 'd
  val many-sep-by 'a 'd : t 'sep 'd -> t 'a 'd -> t (list 'a) 'd
  val between 'open 'close 'a 'd : t 'open 'd -> t 'close 'd -> t 'a 'd -> t 'a 'd
  val pair 'a 'b 'd : t 'a 'd -> t 'b 'd -> t ('a * 'b) 'd
  val triple 'a 'b 'c 'd : t 'a 'd -> t 'b 'd -> t 'c 'd -> t ('a * 'b * 'c) 'd
  val some-chain-left 'a 'd : t ('a -> 'a -> 'a) 'd -> t 'a 'd -> t 'a 'd
end = struct

  % state of parser
  type state 'd = (|
    input : Stream.t (Token.t 'd),
  |)

  % indicates whether backtracking is to be performed on failure; see `alt`
  type consumption = Consumed | Virgin

  val persistent ~(<+>) c1 c2 =
    match (c1, c2) with
    | (Virgin, Virgin) -> Virgin
    | _ -> Consumed
    end

  % (Some a, _, []) -> parsing success with result a
  % (Some a, _, es) -> parsing continued while some errors were found and recovered (e.g. parsing continues after missing `}`)
  type t 'a 'd = state 'd -> option (state 'd * 'a) * consumption * list (parse-error 'd)

  val persistent ~run p s =
    let initial-state = (| input = s |) in
    match p initial-state with
    | (Some (_, a), _, []) ->
      Result.ok a
    | (_, _, es) ->
      Result.err es
    end

  val persistent ~delay t =
    fun state -> (Promise.force t) state

  val persistent ~map f p s =
    match p s with
    | (Some (s, a), c, es) ->
      (Option.some (s, f a), c, es)
    | (None, c, es) ->
      (Option.none, c, es)
    end

  val persistent ~(<&>) p f = map f p

  val persistent ~ret a s =
    (Option.some (s, a), Virgin, [])

  val persistent ~bind k p s =
    match p s with
    | (Some (s, a), c1, e1) ->
      match (k a) s with
      | (Some (s, b), c2, e2) ->
        (Option.some (s, b), c1 <+> c2, List.append e2 e1)
      | (None, c2, e2) ->
        (Option.none, c1 <+> c2, List.append e2 e1)
      end
    | (None, c1, e1) ->
      (Option.none, c1, e1)
    end

  val persistent ~(>>=) p f = bind f p
  val persistent ~(>>) p1 p2 = p1 >>= (fun _ -> p2)
  val persistent ~(<<) p1 p2 = p1 >>= (fun x -> (p2 >> ret x))

  val persistent ~pure = ret
  val persistent ~ap p1 p2 = p2 >>= (fun f -> p1 >>= (fun x -> ret (f x)))
  val persistent ~(<*>) p1 p2 = ap p2 p1
  val persistent ~(*>) = (>>)
  val persistent ~(<*) = (<<)

  val persistent ~traverse f xs =
    let rec aux xs =
      match xs with
      | [] -> pure []
      | x :: xs -> (pure List.cons <*> f x) <*> aux xs
      end
    in aux xs

  val persistent ~sequence xs =
    traverse Fn.id xs

  val persistent ~empty s =
    (Option.none, Virgin, [])

  val persistent ~alt p1 p2 s =
    match p1 s with
    | (None, Virgin, e1) ->
      match p2 s with
      | (None, c, e2) -> (Option.none, c, List.append e2 e1)
      | r -> r
      end
    | r -> r
    end

  val persistent ~(<|>) = alt

  val persistent ~rec
    many p = some p <|> pure []
  and
    some p = p >>= (fun x -> many p >>= (fun xs -> ret (x :: xs)))

  val persistent ~optional p = (pure Option.some <*> p) <|> pure Option.none

  val persistent ~choice ps =
    List.fold-right alt empty ps

  % private API; impredictive choice a la PEG
  val persistent ~(</>) p1 p2 s =
    match p1 s with
    | (None, c1, e1) ->
      let (o, c2, e2) = p2 s in
      (o, c2 <+> c1, List.append e2 e1)
    | r -> r
    end

  val persistent ~make-error s desc =
    (| token = Stream.head s#input, desc = desc |)

  val persistent ~report desc s =
    (Option.some (s, ()), Virgin, [make-error s desc])

  val persistent ~label desc p =
    p </> (report desc >> empty)

  val persistent ~(<?>) p desc = label desc p

  val persistent ~fail desc =
    empty <?> desc

  val persistent ~try p s =
    match p s with
    | (None, _, e) ->
      (Option.none, Virgin, e)
    | r -> r
    end

  val persistent ~lookahead p s =
    match p s with
    | (Some (s, a), _, e) ->
      (Option.some (s, a), Virgin, e)
    | r -> r
    end

  val persistent ~not-followed-by p s =
    match p s with
    | (None, _, _) ->
      (Option.some (s, ()), Virgin, [])
    | _ ->
      (Option.none, Virgin, [])
    end

  val persistent ~catch p s =
    let (o, _, e) = p s in
    (Option.some (s, (o |> Option.map Pair.snd, e)), Virgin, [])

  val persistent ~any s =
    match Stream.uncons s#input with
    | None ->
      (Option.none, Virgin, [])
    | Some(t, new-input) ->
      (Option.some ((| input = new-input |), t), Consumed, [])
    end

  % derived combinators

  val persistent ~eof state =
    (not-followed-by any) state

  val persistent ~satisfy pred =
    try (any >>= (fun t -> (
      if pred t then
        ret t
      else
        empty
    )))

  val persistent ~some-sep-by sep p =
    p >>= (fun x -> many (try (sep >> p)) >>= (fun xs -> ret (x :: xs)))

  val persistent ~many-sep-by sep p = try (some-sep-by sep p) <|> ret []

  val persistent ~between op cl p =
    op >> p >>= (fun x -> cl >> ret x)

  val persistent ~pair p1 p2 =
    (pure Pair.make <*> p1) <*> p2

  val persistent ~triple p1 p2 p3 =
    p1 >>= (fun x -> p2 >>= (fun y -> p3 >>= (fun z -> ret (x, y, z))))

  val persistent ~chain-left op a p =
    many (pair op p) |> map (List.fold-left (fun a (op, b) -> op a b) a)

  val persistent ~some-chain-left op p =
    p >>= (fun x -> p |> chain-left op x)

  val persistent ~fix f =
    let stash = Ref.make empty in
    let main = delay (Promise.delay (fun () -> (!stash))) in
    let () = stash |> Ref.set (f main) in
    main

end
