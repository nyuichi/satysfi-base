use List

module TypesetItemize :> sig

  val itemize2 : (context -> list int -> int -> inline-boxes) -> (int -> int -> length) -> list int -> int -> context -> itemize -> block-boxes

end = struct

  val rec itemize2 f f-item-indent index-lst depth ctx itemize =
    let index =
      match index-lst with
      | [] -> 0
      | x :: xs -> x
      end
    in
    let item-indent = f-item-indent index depth in
    let deco =
      let f _ _ _ _ = unite-graphics [] in
      (f, f, f, f)
    in
    let make-bb ctx it index-lst depth =
      let num-ib =
        f ctx index-lst depth
      in
      let (num-ib-w, _, _) =
        get-natural-metrics num-ib
      in
      let inline-space =
        num-ib-w *' (float (-1)) |> inline-skip
      in
      let main-ib = read-inline ctx it in
        line-break true true ctx (inline-space ++ num-ib ++ main-ib ++ inline-fil)
    in
    let parent-indent = item-indent *' (float depth) in
    let main-bb =
      match itemize with
      | Item(it, [])  ->
          let (bullet-width, _, _) = get-natural-metrics (f ctx index-lst depth) in
          let pads =
            (parent-indent +' bullet-width, 0pt, 0pt, 0pt)
          in
          block-frame-breakable ctx pads deco (fun ctx -> make-bb ctx it index-lst depth)

      | Item(it, lst) ->
          let (bullet-width, _, _) = get-natural-metrics (f ctx index-lst depth) in
          let pads =
            (parent-indent +' bullet-width, 0pt, 0pt, 0pt)
          in
          let index-bb =
            block-frame-breakable ctx pads deco (fun ctx -> make-bb ctx it index-lst depth)
          in
          let bb-lst =
            List.mapi (fun i -> itemize2 f f-item-indent ((i + 1) :: index-lst) (depth + 1) ctx) lst
          in
            index-bb +++ (List.fold-left (+++) block-nil bb-lst)
      end
    in
      main-bb

end
