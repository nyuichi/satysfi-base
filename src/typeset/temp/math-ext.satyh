@require: pervasives
@require: list
@require: gr

module Math : sig

  direct \math : [math] inline-cmd
  direct +math : [inline-text?; math] block-cmd
  direct \eqn : [inline-text?; math] inline-cmd
  direct +math-list : [math list] block-cmd
  direct \math-list : [math list] inline-cmd
  direct +align : [(math list) list] block-cmd
  direct \align : [(math list) list] inline-cmd
  direct \text : [inline-text] math-cmd
  direct \frac : [math; math] math-cmd
  direct \sqrt : [math] math-cmd
  direct \lower : [math; math] math-cmd
  direct \upper : [math; math] math-cmd
  direct \math-skip : [length] math-cmd
  direct \math-color : [color; math] math-cmd
  val join : math -> math list -> math
  val half-length : length -> length -> length -> length -> length

  direct \mathord : [math] math-cmd
  direct \mathbin : [math] math-cmd
  direct \mathrel : [math] math-cmd
  direct \mathop : [math] math-cmd
  direct \mathprefix : [math] math-cmd
  direct \mathpunct : [math] math-cmd

  direct \math-style : [math-char-class; math] math-cmd
  direct \mathrm : [math] math-cmd
  direct \mathbf : [math] math-cmd
  direct \mathcal : [math] math-cmd
  direct \mathfrak : [math] math-cmd
  direct \mathbb : [math] math-cmd
  direct \bm : [math] math-cmd

  direct \math-style-token : [math-char-class; string] math-cmd
  direct \mathit-token : [string] math-cmd
  direct \mathrm-token : [string] math-cmd
  direct \mathbf-token : [string] math-cmd

  direct \alpha   : [] math-cmd
  direct \beta    : [] math-cmd
  direct \gamma   : [] math-cmd
  direct \delta   : [] math-cmd
  direct \epsilon : [] math-cmd
  direct \zeta    : [] math-cmd
  direct \eta     : [] math-cmd
  direct \theta   : [] math-cmd
  direct \iota    : [] math-cmd
  direct \kappa   : [] math-cmd
  direct \lambda  : [] math-cmd
  direct \mu      : [] math-cmd
  direct \nu      : [] math-cmd
  direct \xi      : [] math-cmd
  direct \omicron : [] math-cmd
  direct \pi      : [] math-cmd
  direct \rho     : [] math-cmd
  direct \sigma   : [] math-cmd
  direct \tau     : [] math-cmd
  direct \upsilon : [] math-cmd
  direct \phi     : [] math-cmd
  direct \chi     : [] math-cmd
  direct \psi     : [] math-cmd
  direct \omega   : [] math-cmd

  direct \Alpha   : [] math-cmd
  direct \Beta    : [] math-cmd
  direct \Gamma   : [] math-cmd
  direct \Delta   : [] math-cmd
  direct \Epsilon : [] math-cmd
  direct \Zeta    : [] math-cmd
  direct \Eta     : [] math-cmd
  direct \Theta   : [] math-cmd
  direct \Iota    : [] math-cmd
  direct \Kappa   : [] math-cmd
  direct \Lambda  : [] math-cmd
  direct \Mu      : [] math-cmd
  direct \Nu      : [] math-cmd
  direct \Xi      : [] math-cmd
  direct \Omicron : [] math-cmd
  direct \Pi      : [] math-cmd
  direct \Rho     : [] math-cmd
  direct \Sigma   : [] math-cmd
  direct \Tau     : [] math-cmd
  direct \Upsilon : [] math-cmd
  direct \Phi     : [] math-cmd
  direct \Chi     : [] math-cmd
  direct \Psi     : [] math-cmd
  direct \Omega   : [] math-cmd

  direct \to : [] math-cmd
  direct \gets : [] math-cmd
  direct \iff : [] math-cmd
  direct \pm : [] math-cmd
  direct \mp : [] math-cmd
  direct \times : [] math-cmd
  direct \setminus : [] math-cmd
  direct \ast : [] math-cmd
  direct \circ : [] math-cmd
  direct \bullet : [] math-cmd
  direct \cap : [] math-cmd
  direct \cup : [] math-cmd
  direct \uplus : [] math-cmd
  direct \sqcap : [] math-cmd
  direct \sqcup : [] math-cmd
  direct \wedge : [] math-cmd
  direct \vee : [] math-cmd
  direct \oplus : [] math-cmd
  direct \ominus : [] math-cmd
  direct \otimes : [] math-cmd
  direct \oslash : [] math-cmd
  direct \neg : [] math-cmd

  direct \vdash : [] math-cmd
  direct \nvdash : [] math-cmd
  direct \dashv : [] math-cmd
  direct \vDash : [] math-cmd
  direct \nvDash : [] math-cmd
  direct \Vdash : [] math-cmd
  direct \nVdash : [] math-cmd
  direct \models : [] math-cmd
  direct \nmodels : [] math-cmd

  direct \colon-rel : [] math-cmd

  direct \leq : [] math-cmd
  direct \geq : [] math-cmd
  direct \equiv : [] math-cmd
  direct \nequiv : [] math-cmd
  direct \neq : [] math-cmd
  direct \sim : [] math-cmd
  direct \nsim : [] math-cmd
  direct \simeq : [] math-cmd
  direct \nsimeq : [] math-cmd
  direct \propto : [] math-cmd
  direct \coloneq : [] math-cmd
  direct \eqcolon : [] math-cmd
  direct \Coloneq : [] math-cmd

  direct \in : [] math-cmd
  direct \nin : [] math-cmd
  direct \ni : [] math-cmd
  direct \nni : [] math-cmd
  direct \subset : [] math-cmd
  direct \supset : [] math-cmd
  direct \nsubset : [] math-cmd
  direct \nsupset : [] math-cmd
  direct \subseteq : [] math-cmd
  direct \supseteq : [] math-cmd
  direct \nsubseteq : [] math-cmd
  direct \nsupseteq : [] math-cmd
  direct \subsetneq : [] math-cmd
  direct \supsetneq : [] math-cmd
  direct \sqsubset : [] math-cmd
  direct \sqsupset : [] math-cmd
  direct \sqsubseteq : [] math-cmd
  direct \sqsupseteq : [] math-cmd
  direct \nsqsubseteq : [] math-cmd
  direct \nsqsupseteq : [] math-cmd
  direct \sqsubsetneq : [] math-cmd
  direct \sqsupsetneq : [] math-cmd
  direct \prec : [] math-cmd
  direct \succ : [] math-cmd
  direct \nprec : [] math-cmd
  direct \nsucc : [] math-cmd
  direct \preccurlyeq : [] math-cmd
  direct \succcurlyeq : [] math-cmd
  direct \precsim : [] math-cmd
  direct \succsim : [] math-cmd
  direct \npreccurlyeq : [] math-cmd
  direct \nsucccurlyeq : [] math-cmd

  direct \emptyset : [] math-cmd
  direct \infty : [] math-cmd
  direct \top : [] math-cmd
  direct \bot : [] math-cmd
  direct \therefore : [] math-cmd
  direct \because : [] math-cmd
  direct \forall : [] math-cmd
  direct \exists : [] math-cmd
  direct \nexists : [] math-cmd
  direct \bigcirc : [] math-cmd

  direct \cdot  : [] math-cmd
  direct \ldots : [] math-cmd
  direct \cdots : [] math-cmd
  direct \vdots : [] math-cmd
  direct \ddots : [] math-cmd
  direct \backddots : [] math-cmd

  direct \lim : [] math-cmd
  direct \colim : [] math-cmd
  direct \max : [] math-cmd
  direct \min : [] math-cmd
  direct \inf : [] math-cmd
  direct \sup : [] math-cmd
  direct \sin : [] math-cmd
  direct \cos : [] math-cmd
  direct \tan : [] math-cmd
  direct \cot : [] math-cmd
  direct \sec : [] math-cmd
  direct \csc : [] math-cmd
  direct \log : [] math-cmd
  direct \tr : [] math-cmd
  direct \det : [] math-cmd
  direct \dom : [] math-cmd
  direct \cod : [] math-cmd
  direct \Ker : [] math-cmd
  direct \Im : [] math-cmd

  direct \sum : [] math-cmd
  direct \prod : [] math-cmd
  direct \coprod : [] math-cmd
  direct \bigwedge : [] math-cmd
  direct \bigvee : [] math-cmd
  direct \bigcap : [] math-cmd
  direct \bigcup : [] math-cmd
  direct \bigsqcup : [] math-cmd

  direct \lnot : [] math-cmd
  direct \land : [] math-cmd
  direct \lor : [] math-cmd

  direct \Leftarrow : [] math-cmd
  direct \Rightarrow : [] math-cmd
  direct \Leftrightarrow : [] math-cmd
  direct \Uparrow : [] math-cmd
  direct \Downarrow : [] math-cmd
  direct \Updownarrow : [] math-cmd
  direct \nRightarrow : [] math-cmd
  direct \nLeftarrow : [] math-cmd
  direct \nLeftrightarrow : [] math-cmd
  direct \leftarrow : [] math-cmd
  direct \rightarrow : [] math-cmd
  direct \leftrightarrow : [] math-cmd
  direct \uparrow : [] math-cmd
  direct \downarrow : [] math-cmd
  direct \updownarrow : [] math-cmd
  direct \nwarrow : [] math-cmd
  direct \nearrow : [] math-cmd
  direct \searrow : [] math-cmd
  direct \swarrow : [] math-cmd
  direct \nleftarrow : [] math-cmd
  direct \nrightarrow : [] math-cmd
  direct \nleftrightarrow : [] math-cmd
  direct \mapsto : [] math-cmd
  direct \longmapsto : [] math-cmd
  direct \hookleftarrow : [] math-cmd
  direct \hookrightarrow : [] math-cmd
  direct \rightarrowtail : [] math-cmd
  direct \leftarrowtail : [] math-cmd
  direct \twoheadleftarrow : [] math-cmd
  direct \twoheadrightarrow : [] math-cmd
  direct \twoheaduparrow : [] math-cmd
  direct \twoheaddownarrow : [] math-cmd
  direct \leftharpoonup : [] math-cmd
  direct \leftharpoondown : [] math-cmd
  direct \rightharpoonup : [] math-cmd
  direct \rightharpoondown : [] math-cmd
  direct \rightleftharpoons : [] math-cmd
  direct \upharpoonright : [] math-cmd
  direct \upharpoonleft : [] math-cmd
  direct \downharpoonright : [] math-cmd
  direct \downharpoonleft : [] math-cmd
  direct \longleftarrow : [] math-cmd
  direct \longrightarrow : [] math-cmd
  direct \longleftrightarrow : [] math-cmd
  direct \Longleftarrow : [] math-cmd
  direct \Longrightarrow : [] math-cmd
  direct \Longleftrightarrow : [] math-cmd
  direct \circlearrowleft : [] math-cmd
  direct \circlearrowright : [] math-cmd

  direct \between : [] math-cmd
  direct \pitchfork : [] math-cmd
  direct \intercal : [] math-cmd
  direct \ll : [] math-cmd
  direct \gg : [] math-cmd
  direct \lll : [] math-cmd
  direct \ggg : [] math-cmd
  direct \leqq : [] math-cmd
  direct \geqq : [] math-cmd
  direct \lneqq : [] math-cmd
  direct \gneqq : [] math-cmd
  direct \lnsim : [] math-cmd
  direct \gnsim : [] math-cmd
  direct \precnsim : [] math-cmd
  direct \succnsim : [] math-cmd
  direct \Subset : [] math-cmd
  direct \Supset : [] math-cmd
  direct \Cap : [] math-cmd
  direct \Cup : [] math-cmd
  direct \lhd : [] math-cmd
  direct \rhd : [] math-cmd
  direct \unlhd : [] math-cmd
  direct \unrhd : [] math-cmd
  direct \triangleleft : [] math-cmd
  direct \triangleright : [] math-cmd
  direct \trianglelefteq : [] math-cmd
  direct \trianglerighteq : [] math-cmd
  direct \backsim : [] math-cmd
  direct \backsimeq : [] math-cmd
  direct \eqcirc : [] math-cmd
  direct \cong : [] math-cmd
  direct \simneq : [] math-cmd
  direct \ncong : [] math-cmd
  direct \approx : [] math-cmd
  direct \napprox : [] math-cmd
  direct \approxeq : [] math-cmd
  direct \curlyeqprec : [] math-cmd
  direct \curlyeqsucc : [] math-cmd
  direct \lessdot : [] math-cmd
  direct \gtrdot : [] math-cmd
  direct \lesssim : [] math-cmd
  direct \gtrsim : [] math-cmd
  direct \nlesssim : [] math-cmd
  direct \ngtrsim : [] math-cmd
  direct \lessgtr : [] math-cmd
  direct \gtrless : [] math-cmd
  direct \nlessgtr : [] math-cmd
  direct \ngtrless : [] math-cmd
  direct \ntriangleleft : [] math-cmd
  direct \ntriangleright : [] math-cmd
  direct \ntrianglelefteq : [] math-cmd
  direct \ntrianglerighteq : [] math-cmd
  direct \lesseqgtr : [] math-cmd
  direct \gtreqless : [] math-cmd
  direct \nless : [] math-cmd
  direct \ngtr : [] math-cmd
  direct \nleq : [] math-cmd
  direct \ngeq : [] math-cmd
  direct \asymp : [] math-cmd
  direct \nasymp : [] math-cmd
  direct \circeq : [] math-cmd
  direct \Bumpeq : [] math-cmd
  direct \bumpeq : [] math-cmd
  direct \doteq : [] math-cmd
  direct \doteqdot : [] math-cmd
  direct \fallingdotseq : [] math-cmd
  direct \risingdotseq : [] math-cmd
  direct \mid : [] math-cmd
  direct \nmid : [] math-cmd
  direct \parallel : [] math-cmd
  direct \nparallel : [] math-cmd
  direct \Vvdash : [] math-cmd
  direct \VDash : [] math-cmd
  direct \coloncoloneq : [] math-cmd
  direct \leqslant : [] math-cmd
  direct \geqslant : [] math-cmd
  direct \dashV : [] math-cmd
  direct \Dashv : [] math-cmd
  direct \DashV : [] math-cmd
  direct \preceq : [] math-cmd
  direct \succeq : [] math-cmd

  direct \amalg : [] math-cmd
  direct \dotplus : [] math-cmd
  direct \divideontimes : [] math-cmd
  direct \odot : [] math-cmd
  direct \circledcirc : [] math-cmd
  direct \circledast : [] math-cmd
%  direct \circledeq : [] math-cmd
  direct \circleddash : [] math-cmd
  direct \boxplus : [] math-cmd
  direct \boxminus : [] math-cmd
  direct \boxtimes : [] math-cmd
  direct \boxdot : [] math-cmd
  direct \curlyvee : [] math-cmd
  direct \curlywedge : [] math-cmd
  direct \Join : [] math-cmd
  direct \ltimes : [] math-cmd
  direct \rtimes : [] math-cmd
  direct \leftthreetimes : [] math-cmd
  direct \rightthreetimes : [] math-cmd
  direct \wr : [] math-cmd
  direct \bowtie : [] math-cmd

  direct \diamond : [] math-cmd
  direct \star : [] math-cmd
  direct \complement : [] math-cmd
  direct \angle : [] math-cmd
  direct \measuredangle : [] math-cmd
  direct \sphericalangle : [] math-cmd
  direct \QED : [] math-cmd

  direct \int : [] math-cmd

  direct \ordd : [] math-cmd
  direct \partial : [] math-cmd
  direct \nabla : [] math-cmd

  direct \paren : [math] math-cmd
  direct \app : [math; math] math-cmd
  direct \angle-bracket : [math] math-cmd
  direct \brace : [math] math-cmd
  direct \sqbracket : [math] math-cmd
  direct \abs : [math] math-cmd
  direct \norm : [math] math-cmd
  direct \floor : [math] math-cmd
  direct \ceil : [math] math-cmd
  direct \set : [math] math-cmd
  direct \setsep : [math; math] math-cmd
  direct \cases : [(math * inline-text) list] math-cmd

  val paren-left : paren
  val paren-right : paren
  val angle-left : length -> paren
  val angle-right : length -> paren
  val brace-left : paren
  val brace-right : paren
  val sqbracket-left : paren
  val sqbracket-right : paren
  val floor-left : paren
  val floor-right : paren
  val ceil-left : paren
  val ceil-right : paren
  val abs-left : paren
  val abs-right : paren
  val norm-left : paren
  val norm-right : paren
  val empty-paren : paren
  val bar-middle : paren
  val slash-middle : paren

  % -- temporary --
  direct \synteq : [] math-cmd
  direct \tyjd : [math; math; math] math-cmd
  direct \and-also : [] math-cmd
  direct \tmabstyped : [math; math; math] math-cmd

end = struct

  let join msep mlst =
    match
      mlst |> List.fold-left (fun maccopt m -> (
        match maccopt with
        | None       -> Some(m)
        | Some(macc) -> Some(${#macc #msep #m})
      )) None
    with
    | None       -> ${}
    | Some(macc) -> macc


  let margin-ratio = 1.


  let-inline ctx \math fml =
      script-guard Latin (embed-math ctx fml)

  let-math \frac = math-frac

  let-math \sqrt = math-radical None

  let-math \lower = math-lower

  let-math \upper = math-upper

  let-math \text it =
    text-in-math MathOrd (fun ctx -> read-inline ctx it)

  let-math \math-skip len =
    text-in-math MathOrd (fun _ -> inline-skip len)

  let-math \math-color color m =
    math-color color m


  let-math \mathord = math-group MathOrd MathOrd
  let-math \mathbin = math-group MathBin MathBin
  let-math \mathrel = math-group MathRel MathRel
  let-math \mathop = math-group MathOp MathOp
  let-math \mathprefix = math-group MathPrefix MathPrefix
  let-math \mathpunct = math-group MathPunct MathPunct

  let-math \math-style sty m =
    math-char-class sty m

  let-math \mathrm m = ${\math-style!(MathRoman){#m}}
  let-math \mathbf m = ${\math-style!(MathBoldRoman){#m}}
  let-math \mathcal m = ${\math-style!(MathScript){#m}}
  let-math \mathfrak m = ${\math-style!(MathFraktur){#m}}
  let-math \mathbb m = ${\math-style!(MathDoubleStruck){#m}}
  let-math \bm m = ${\math-style!(MathBoldItalic){#m}}


  let-math \math-style-token sty s =
    text-in-math MathOrd (fun ctx -> (
    let sm = convert-string-for-math ctx sty s in
      embed-math ctx (math-char MathOrd sm)
    ))

  let-math \mathit-token s = ${\math-style-token!(MathItalic)!(s)}
  let-math \mathrm-token s = ${\math-style-token!(MathRoman)!(s)}
  let-math \mathbf-token s = ${\math-style-token!(MathBoldRoman)!(s)}


  let math-scheme ctx tagopt math =
    let ib = embed-math ctx math in
      match tagopt with
      | None      -> line-break true true ctx (inline-fil ++ ib ++ inline-fil)
      | Some(tag) -> line-break true true ctx (inline-fil ++ ib ++ inline-fil ++ read-inline ctx tag)


  let-block ctx +math ?:tagopt math =
    math-scheme ctx tagopt math


  let-inline ctx \eqn ?:tagopt math =
    inline-fil ++
      embed-block-breakable ctx (math-scheme ctx tagopt math)
        ++ omit-skip-after


  let-block ctx +math-list mlst =
    let mingap = get-font-size ctx *' 2. in
    let ib-fil =
      discretionary 100 (inline-skip mingap ++ inline-fil) inline-fil inline-fil
    in
    let ib =
      mlst |> List.fold-left-adjacent (fun ibacc m _ optnext -> (
        let ib-after =
          match optnext with
          | None    -> inline-fil
          | Some(_) -> ib-fil
        in
          ibacc ++ embed-math ctx m ++ ib-after
      )) inline-fil
    in
    let margin = get-font-size ctx *' margin-ratio in
    let ctx =
      ctx |> set-min-gap-of-lines 12pt
          |> set-paragraph-margin margin margin
    in
      line-break true true ctx ib


  let-inline ctx \math-list mlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+math-list(mlst);>)
        ++ omit-skip-after


  let-block ctx +align mlstlst =
    let vlen = 4pt in
    let lengap = get-font-size ctx *' 2. in
    let celllstlst =
      mlstlst |> List.map (fun mlst -> (
        mlst |> List.mapi-adjacent (fun index m _ mnextopt -> (
          let ibm = embed-math ctx m in
          let ib =
            match mnextopt with
            | None ->
                ibm

            | Some(mnext) ->
                let ibspaceopt = space-between-maths ctx m mnext in
                ( match ibspaceopt with
                  | None          -> ibm
                  | Some(ibspace) -> ibm ++ ibspace
                )
          in
          let ib =
            if index mod 2 == 0 then
              inline-fil ++ ib
            else
              match mnextopt with
              | None    -> ib ++ inline-fil
              | Some(_) -> ib ++ inline-fil ++ inline-skip lengap
          in
            NormalCell((0pt, 0pt, vlen, vlen), ib)
        ))
      ))
    in
    let margin = get-font-size ctx *' margin-ratio in
      line-break true true (ctx |> set-paragraph-margin margin margin)
        (inline-fil ++ (tabular celllstlst (fun _ _ -> [])) ++ inline-fil)
        % temporary


  let-inline ctx \align mlstlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+align(mlstlst);>)
        ++ omit-skip-after


  let math-list lst =
    lst |> List.fold-left math-concat (math-char MathOrd ` `)


  let single cp = string-unexplode [cp]


  let greek-lowercase cp cpb =
    let s = single cp in
    let sb = single cpb in
      math-variant-char MathOrd (|
        italic        = s;
        bold-italic   = sb;
        roman         = s;
        bold-roman    = sb;
        script        = s;
        bold-script   = sb;
        fraktur       = s;
        bold-fraktur  = sb;
        double-struck = s;
      |)


  let greek-uppercase cp cpb cpr cprb =
    let s = single cp in
    let sb = single cpb in
    let sr = single cpr in
    let srb = single cprb in
      math-variant-char MathOrd (|
        italic        = s;
        bold-italic   = sb;
        roman         = sr;
        bold-roman    = srb;
        script        = s;
        bold-script   = sb;
        fraktur       = s;
        bold-fraktur  = sb;
        double-struck = s;
      |)

  let-math \alpha    = greek-lowercase 0x1D6FC 0x1D736
  let-math \beta     = greek-lowercase 0x1D6FD 0x1D737
  let-math \gamma    = greek-lowercase 0x1D6FE 0x1D738
  let-math \delta    = greek-lowercase 0x1D6FF 0x1D739
  let-math \epsilon  = greek-lowercase 0x1D700 0x1D73A
  let-math \zeta     = greek-lowercase 0x1D701 0x1D73B
  let-math \eta      = greek-lowercase 0x1D702 0x1D73C
  let-math \theta    = greek-lowercase 0x1D703 0x1D73D
  let-math \iota     = greek-lowercase 0x1D704 0x1D73E
  let-math \kappa    = greek-lowercase 0x1D705 0x1D73F
  let-math \lambda   = greek-lowercase 0x1D706 0x1D740
  let-math \mu       = greek-lowercase 0x1D707 0x1D741
  let-math \nu       = greek-lowercase 0x1D708 0x1D742
  let-math \xi       = greek-lowercase 0x1D709 0x1D743
  let-math \omicron  = greek-lowercase 0x1D70A 0x1D744
  let-math \pi       = greek-lowercase 0x1D70B 0x1D745
  let-math \rho      = greek-lowercase 0x1D70C 0x1D746
  let-math \sigma    = greek-lowercase 0x1D70E 0x1D748
  let-math \tau      = greek-lowercase 0x1D70F 0x1D749
  let-math \upsilon  = greek-lowercase 0x1D710 0x1D74A
  let-math \phi      = greek-lowercase 0x1D711 0x1D74B
  let-math \chi      = greek-lowercase 0x1D712 0x1D74C
  let-math \psi      = greek-lowercase 0x1D713 0x1D74D
  let-math \omega    = greek-lowercase 0x1D714 0x1D74E

  let-math \Alpha    = greek-uppercase 0x1D6E2 0x1D71C 0x0391 0x1D6A8
  let-math \Beta     = greek-uppercase 0x1D6E3 0x1D71D 0x0392 0x1D6A9
  let-math \Gamma    = greek-uppercase 0x1D6E4 0x1D71E 0x0393 0x1D6AA
  let-math \Delta    = greek-uppercase 0x1D6E5 0x1D71F 0x0394 0x1D6AB
  let-math \Epsilon  = greek-uppercase 0x1D6E6 0x1D720 0x0395 0x1D6AC
  let-math \Zeta     = greek-uppercase 0x1D6E7 0x1D721 0x0396 0x1D6AD
  let-math \Eta      = greek-uppercase 0x1D6E8 0x1D722 0x0397 0x1D6AE
  let-math \Theta    = greek-uppercase 0x1D6E9 0x1D723 0x0398 0x1D6AF
  let-math \Iota     = greek-uppercase 0x1D6EA 0x1D724 0x0399 0x1D6B0
  let-math \Kappa    = greek-uppercase 0x1D6EB 0x1D725 0x039A 0x1D6B1
  let-math \Lambda   = greek-uppercase 0x1D6EC 0x1D726 0x039B 0x1D6B2
  let-math \Mu       = greek-uppercase 0x1D6ED 0x1D727 0x039C 0x1D6B3
  let-math \Nu       = greek-uppercase 0x1D6EE 0x1D728 0x039D 0x1D6B4
  let-math \Xi       = greek-uppercase 0x1D6EF 0x1D729 0x039E 0x1D6B5
  let-math \Omicron  = greek-uppercase 0x1D6F0 0x1D72A 0x039F 0x1D6B6
  let-math \Pi       = greek-uppercase 0x1D6F1 0x1D72B 0x03A0 0x1D6B7
  let-math \Rho      = greek-uppercase 0x1D6F2 0x1D72C 0x03A1 0x1D6B8
  let-math \Sigma    = greek-uppercase 0x1D6F4 0x1D72E 0x03A3 0x1D6BA
  let-math \Tau      = greek-uppercase 0x1D6F5 0x1D72F 0x03A4 0x1D6BB
  let-math \Upsilon  = greek-uppercase 0x1D6F6 0x1D730 0x03A5 0x1D6BC
  let-math \Phi      = greek-uppercase 0x1D6F7 0x1D731 0x03A6 0x1D6BD
  let-math \Chi      = greek-uppercase 0x1D6F8 0x1D732 0x03A7 0x1D6BE
  let-math \Psi      = greek-uppercase 0x1D6F9 0x1D733 0x03A8 0x1D6BF
  let-math \Omega    = greek-uppercase 0x1D6FA 0x1D734 0x03A9 0x1D6C0

  let ord = math-char MathOrd
  let bin = math-char MathBin
  let rel = math-char MathRel
  let op = math-char MathOp
  let punct = math-char MathPunct
  let prefix = math-char MathPrefix

  let vop-scheme charf s =
    let mop = charf MathOp s in
      math-pull-in-scripts MathOp MathOp
        (fun moptS moptT -> (
          let m =
            match moptS with
            | None     -> mop
            | Some(mS) -> math-lower mop mS
          in
            match moptT with
            | None     -> m
            | Some(mT) -> math-upper m mT
        ))

  let bigop = vop-scheme math-big-char
  let vop = vop-scheme math-char

  let-math \to    = rel `→`
  let-math \gets  = rel `←`
  let-math \iff   = rel `⟺`
  let-math \pm    = bin `±`
  let-math \mp    = bin `∓`
  let-math \times = bin `×`
  let-math \setminus = bin `∖`
  let-math \ast = bin `∗`
  let-math \circ = bin `∘`
  let-math \bullet = bin `∙`
  let-math \cap = bin `∩`
  let-math \cup = bin `∪`
  let-math \uplus = bin `⊎`
  let-math \sqcap = bin `⊓`
  let-math \sqcup = bin `⊔`
  let-math \wedge = bin `∧`
  let-math \vee   = bin `∨`
  let-math \oplus = bin `⊕`
  let-math \ominus = bin `⊖`
  let-math \otimes = bin `⊗`
  let-math \oslash = bin `⊘`
  let-math \neg    = op `¬`

  let-math \vdash = rel `⊢`
  let-math \nvdash = rel `⊬`
  let-math \dashv = rel `⊣`
  let-math \vDash = rel `⊨`
  let-math \nvDash = rel `⊭`
  let-math \Vdash = rel `⊩`
  let-math \nVdash = rel `⊮`
  let-math \models = rel `⊧`
  let-math \nmodels = rel `⊭`

  let-math \colon-rel = rel `:`

  let-math \leq = rel `≤`
  let-math \geq = rel `≥`
  let-math \equiv = rel `≡`
  let-math \nequiv = rel `≢`
  let-math \neq = rel `≠`
  let-math \sim = rel `∼`
  let-math \nsim = rel `≁`
  let-math \simeq = rel `≃`
  let-math \nsimeq = rel `≄`
  let-math \propto = rel `∝`
  let-math \coloneq = rel `≔`
  let-math \eqcolon = rel `≕`
  let-math \Coloneq = rel `⩴`

  let-math \in = rel `∈`
  let-math \nin = rel `∉`
  let-math \ni = rel `∋`
  let-math \nni = rel `∌`
  let-math \subset = rel `⊂`
  let-math \supset = rel `⊃`
  let-math \nsubset = rel `⊄`
  let-math \nsupset = rel `⊅`
  let-math \subseteq = rel `⊆`
  let-math \supseteq = rel `⊇`
  let-math \nsubseteq = rel `⊈`
  let-math \nsupseteq = rel `⊉`
  let-math \subsetneq = rel `⊊`
  let-math \supsetneq = rel `⊋`
  let-math \sqsubset = rel `⊏`
  let-math \sqsupset = rel `⊐`
  let-math \sqsubseteq = rel `⊑`
  let-math \sqsupseteq = rel `⊒`
  let-math \nsqsubseteq = rel `⋢`
  let-math \nsqsupseteq = rel `⋣`
  let-math \sqsubsetneq = rel `⋤`
  let-math \sqsupsetneq = rel `⋥`
  let-math \prec = rel `≺`
  let-math \succ = rel`≻`
  let-math \nprec = rel `⊀`
  let-math \nsucc = rel `⊁`
  let-math \preccurlyeq = rel`≼`
  let-math \succcurlyeq = rel `≽`
  let-math \precsim = rel `≾`
  let-math \succsim = rel `≿`
  let-math \npreccurlyeq = rel `⋠`
  let-math \nsucccurlyeq = rel `⋡`

  let-math \emptyset = ord `∅`
  let-math \infty = ord `∞`
  let-math \top = ord `⊤`
  let-math \bot = ord `⊥`
  let-math \therefore = ord `∴`
  let-math \because = ord `∵`
  let-math \forall = ord `∀`
  let-math \exists = ord `∃`
  let-math \nexists = ord `∄`
  let-math \bigcirc = ord `◯`

  let-math \cdot  = bin `⋅`
  let-math \ldots = ord `…`
  let-math \cdots = math-char MathInner `⋯`
  let-math \vdots = ord `⋮`
  let-math \ddots = ord `⋱`
  let-math \backddots = ord `⋰`

  let-math \lim = vop `lim`
  let-math \colim = vop `colim`
  let-math \max = vop `max`
  let-math \min = vop `min`
  let-math \inf = vop `inf`
  let-math \sup = vop `sup`
  let-math \sin = op `sin`
  let-math \cos = op `cos`
  let-math \tan = op `tan`
  let-math \cot = op `cot`
  let-math \sec = op `sec`
  let-math \csc = op `csc`
  let-math \log = op `log`
  let-math \tr  = op `tr`
  let-math \det = op `det`
  let-math \dom = op `dom`
  let-math \cod = op `cod`
  let-math \Ker = op `Ker`
  let-math \Im = op `Im`

  let-math \sum = bigop `∑`
  let-math \prod = bigop `∏`
  let-math \coprod = bigop `∐`
  let-math \bigwedge = bigop `⋀`
  let-math \bigvee = bigop `⋁`
  let-math \bigcap = bigop `⋂`
  let-math \bigcup = bigop `⋃`
  let-math \bigsqcup = bigop `∐`

  let-math \lnot = op `¬`
  let-math \land = rel `∧`
  let-math \lor  = rel `∨`

  let-math \Leftarrow = rel `⇐`
  let-math \Rightarrow = rel `⇒`
  let-math \Leftrightarrow = rel `⇔`
  let-math \Uparrow = rel `⇑`
  let-math \Downarrow = rel `⇓`
  let-math \Updownarrow = rel `⇕`
  let-math \nRightarrow = rel `⇍`
  let-math \nLeftarrow = rel `⇏`
  let-math \nLeftrightarrow = rel `⇎`
  let-math \leftarrow = rel `←`
  let-math \rightarrow = rel `→`
  let-math \leftrightarrow = rel `↔`
  let-math \uparrow = rel `↑`
  let-math \downarrow = rel `↓`
  let-math \updownarrow = rel `↕`
  let-math \nwarrow = rel `↖`
  let-math \nearrow = rel `↗`
  let-math \searrow = rel `↘`
  let-math \swarrow = rel `↙`
  let-math \nleftarrow = rel `↚`
  let-math \nrightarrow = rel `↛`
  let-math \nleftrightarrow = rel `↮`
  let-math \mapsto = rel `↦`
  let-math \longmapsto = rel `⟼`
  let-math \hookleftarrow = rel `↩`
  let-math \hookrightarrow = rel `↪`
  let-math \rightarrowtail = rel `↣`
  let-math \leftarrowtail = rel `↢`
  let-math \twoheadleftarrow = rel `↞`
  let-math \twoheadrightarrow = rel `↠`
  let-math \twoheaduparrow = rel `↟`
  let-math \twoheaddownarrow = rel `↡`
  let-math \leftharpoonup = rel `↼`
  let-math \leftharpoondown = rel `↽`
  let-math \rightharpoonup = rel `⇀`
  let-math \rightharpoondown = rel `⇁`
  let-math \rightleftharpoons = rel `⇌`
  let-math \upharpoonright = rel `↾`
  let-math \upharpoonleft = rel `↿`
  let-math \downharpoonright = rel `⇂`
  let-math \downharpoonleft = rel `⇃`
  let-math \longleftarrow = rel `⟵`
  let-math \longrightarrow = rel `⟶`
  let-math \longleftrightarrow = rel `⟷`
  let-math \Longleftarrow = rel `⟸`
  let-math \Longrightarrow = rel `⟹`
  let-math \Longleftrightarrow = rel `⟺`
  let-math \circlearrowleft = rel `↺`
  let-math \circlearrowright = rel `↻`

  let-math \between = rel `≬`
  let-math \pitchfork = rel `⋔`
  let-math \intercal = rel `⊺`
  let-math \ll = rel `≪`
  let-math \gg = rel `≫`
  let-math \lll = rel `⋘`
  let-math \ggg = rel `⋙`
  let-math \leqq = rel `≦`
  let-math \geqq = rel `≧`
  let-math \lneqq = rel `≨`
  let-math \gneqq = rel `≩`
  let-math \lnsim = rel `⋦`
  let-math \gnsim = rel `⋧`
  let-math \precnsim = rel `⋨`
  let-math \succnsim = rel `⋩`
  let-math \Subset = rel `⋐`
  let-math \Supset = rel `⋑`
  let-math \Cap = bin `⋒`
  let-math \Cup = bin `⋓`
  let-math \lhd = rel `⊲`
  let-math \rhd = rel `⊳`
  let-math \unlhd = rel `⊴`
  let-math \unrhd = rel `⊵`
  let-math \triangleleft = rel `⊲`
  let-math \triangleright = rel `⊳`
  let-math \trianglelefteq = rel `⊴`
  let-math \trianglerighteq = rel `⊵`
  let-math \backsim = rel `∽`
  let-math \backsimeq = rel `⋍`
  let-math \eqcirc = rel `≖`
  let-math \cong = rel `≅`
  let-math \simneq = rel `≆`
  let-math \ncong = rel `≇`
  let-math \approx = rel `≈`
  let-math \napprox = rel `≉`
  let-math \approxeq = rel `≊`
  let-math \curlyeqprec = rel `⋞`
  let-math \curlyeqsucc = rel `⋟`
  let-math \lessdot = rel `⋖`
  let-math \gtrdot = rel `⋗`
  let-math \lesssim = rel `≲`
  let-math \gtrsim = rel `≳`
  let-math \nlesssim = rel `≴`
  let-math \ngtrsim = rel `≵`
  let-math \lessgtr = rel `≶`
  let-math \gtrless = rel `≷`
  let-math \nlessgtr = rel `≸`
  let-math \ngtrless = rel `≹`
  let-math \ntriangleleft = rel `⋪`
  let-math \ntriangleright = rel `⋫`
  let-math \ntrianglelefteq = rel `⋬`
  let-math \ntrianglerighteq = rel `⋭`
  let-math \lesseqgtr = rel `⋚`
  let-math \gtreqless = rel `⋛`
  let-math \nless = rel `≮`
  let-math \ngtr = rel `≯`
  let-math \nleq = rel `≰`
  let-math \ngeq = rel `≱`
  let-math \asymp = rel `≍`
  let-math \nasymp = rel `≭`
  let-math \circeq = rel `≗`
  let-math \Bumpeq = rel `≎`
  let-math \bumpeq = rel `≏`
  let-math \doteq = rel `≐`
  let-math \doteqdot = rel `≑`
  let-math \fallingdotseq = rel `≒`
  let-math \risingdotseq = rel `≓`
  let-math \mid = rel `∣`
  let-math \nmid = rel `∤`
  let-math \parallel = rel `∥`
  let-math \nparallel = rel `∦`
  let-math \Vvdash = rel `⊪`
  let-math \VDash = rel `⊫`
  let-math \coloncoloneq = rel `⩴`
  let-math \leqslant = rel `⩽`
  let-math \geqslant = rel `⩾`
  let-math \dashV = rel `⫣`
  let-math \Dashv = rel `⫤`
  let-math \DashV = rel `⫥`
  let-math \preceq = rel `⪯`
  let-math \succeq = rel `⪰`

  let-math \amalg = bin `⨿`
  let-math \dotplus = bin `∔`
  let-math \divideontimes = bin `⋇`
  let-math \odot = bin `⊙`
  let-math \circledcirc = bin `⊚`
  let-math \circledast = bin `⊛`
%  let-math \circledeq = bin `⊜`
  let-math \circleddash = bin `⊝`
  let-math \boxplus = bin `⊞`
  let-math \boxminus = bin `⊟`
  let-math \boxtimes = bin `⊠`
  let-math \boxdot = bin `⊡`
  let-math \curlyvee = bin `⋎`
  let-math \curlywedge = bin `⋏`
  let-math \Join = bin `⋈`
  let-math \ltimes = bin `⋉`
  let-math \rtimes = bin `⋊`
  let-math \leftthreetimes = bin `⋋`
  let-math \rightthreetimes = bin `⋌`
  let-math \wr = bin `≀`
  let-math \bowtie = bin `⋈`

  let-math \diamond = ord `⋄`
  let-math \star = ord `⋆`
  let-math \complement = ord `∁`
  let-math \angle = ord `∠`
  let-math \measuredangle = ord `∡`
  let-math \sphericalangle = rel `∢`
  let-math \QED = ord `∎`

  let-math \ordd = prefix `d`
  let-math \partial = prefix `∂`
  let-math \nabla  = prefix `∇`

%% -- for Latin Modern Math --
  let-math \int =
    let kernfL _ _ = 0pt in
    let kernfR fontsize ypos = fontsize *' 0.45 in
      math-big-char-with-kern MathOp `∫` kernfL kernfR

%% -- for Cambria Math --
%  let-math \int =
%    let kernfL _ _ = 0pt in
%    let kernfR fontsize ypos = fontsize *' 0.2 in
%      math-big-char-with-kern MathOp `∫` kernfL kernfR

  let math-space =
    text-in-math MathOrd (fun ctx -> inline-skip 30pt)

  let-math \and-also = math-space

  let-math \tyjd tyenv tm ty =
    ${#tyenv \vdash #tm \colon-rel #ty}

  let-math \synteq = ${\equiv}

  let-math \dot-punct =
    math-char MathPunct `.`

  let-math \tmabstyped var ty body =
    ${\lambda #var \colon-rel #ty \dot-punct #body}

  let-math \npe =
    math-color (RGB(1., 0., 0.)) (math-char-class MathRoman ${e})

  let-math \bi m =
    math-char-class MathBoldItalic m

  let half-length hgt dpt hgtaxis fontsize =
    let minhalflen = fontsize *' 0.5 in
    let lenappend = fontsize *' 0.1 in
      length-max minhalflen ((length-max (hgt -' hgtaxis) (hgtaxis +' dpt)) +' lenappend)

  let angle-left thk hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let widparen = halflen *' 0.375 in
    let wid = widparen +' fontsize *' 0.1 in
    let path (xpos, ypos) =
      start-path (xpos +' wid, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid -' widparen, ypos +' hgtaxis)
        |> line-to (xpos +' wid, ypos +' hgtaxis -' halflen)
        |> terminate-path
    in
    let graphics point = [ stroke thk color (path point); ] in
    let kerninfo y =
      let widkern = widparen in
      let r = 0. in
      let gap = length-abs (y -' hgtaxis) in
        if halflen *' r <' gap then
          widkern *' ((gap -' halflen *' r) /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  let angle-right thk hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let widparen = halflen *' 0.375 in
    let wid = widparen +' fontsize *' 0.1 in
    let path (xpos, ypos) =
      start-path (xpos, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' widparen, ypos +' hgtaxis)
        |> line-to (xpos, ypos +' hgtaxis -' halflen)
        |> terminate-path
    in
    let graphics point = [ stroke thk color (path point); ] in
    let kerninfo y =
      let widkern = widparen in
      let r = 0. in
      let gap = length-abs (y -' hgtaxis) in
        if halflen *' r <' gap then
          widkern *' ((gap -' halflen *' r) /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  let-math \angle-bracket =
    math-paren (angle-left 0.5pt) (angle-right 0.5pt)

  let paren-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.075 +' halflen *' 0.01 in
    let w2 = halflen *' 0.25 in %temporary
    let w-extra = fontsize *' 0.1 in
    let t1 = fontsize *' 0.025 in
    let t2 = fontsize *' 0.025 in

    let qA = halflen *' 0.35 in
    let p1 = (w1 +' w2) *' 0.75 in
    let q1 = halflen *' 0.3 in

    let qB = halflen *' 0.45 in
    let p2 = w2 *' 0.5 in
    let q2 = halflen *' 0.2 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let x0 = xpos +' w0 in
      let x1 = x0 +' w1 in
      let x2 = x1 +' w2 in
      start-path (x2, ycenter +' halflen)
        |> bezier-to (x2 -' p1, ycenter +' halflen -' q1) (x0, ycenter +' qA) (x0, ycenter)
        |> bezier-to (x0, ycenter -' qA) (x2 -' p1, ycenter -' halflen +' q1) (x2, ycenter -' halflen)
        |> line-to (x2 +' t1, ycenter -' halflen +' t2)
        |> bezier-to (x2 -' p2, ycenter -' halflen +' q2) (x1, ycenter -' qB) (x1, ycenter)
        |> bezier-to (x1, ycenter +' qB) (x2 -' p2, ycenter +' halflen -' q2) (x2 +' t1, ycenter +' halflen -' t2)
        |> close-with-line
    in
    let graphics point = [ fill color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics (w0 +' w1 +' w2 +' w-extra) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  let paren-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.075 +' halflen *' 0.01 in
    let w2 = halflen *' 0.25 in %temporary
    let w-extra = fontsize *' 0.1 in
    let t1 = 0pt -' fontsize *' 0.025 in
    let t2 = fontsize *' 0.025 in

    let qA = halflen *' 0.35 in
    let p1 = 0pt -' (w1 +' w2) *' 0.75 in
    let q1 = halflen *' 0.3 in

    let qB = halflen *' 0.45 in
    let p2 = 0pt -' w2 *' 0.5 in
    let q2 = halflen *' 0.2 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let x0 = xpos +' w-extra +' w2 +' w1 in
      let x1 = xpos +' w-extra +' w2 in
      let x2 = xpos +' w-extra in
      start-path (x2, ycenter +' halflen)
        |> bezier-to (x2 -' p1, ycenter +' halflen -' q1) (x0, ycenter +' qA) (x0, ycenter)
        |> bezier-to (x0, ycenter -' qA) (x2 -' p1, ycenter -' halflen +' q1) (x2, ycenter -' halflen)
        |> line-to (x2 +' t1, ycenter -' halflen +' t2)
        |> bezier-to (x2 -' p2, ycenter -' halflen +' q2) (x1, ycenter -' qB) (x1, ycenter)
        |> bezier-to (x1, ycenter +' qB) (x2 -' p2, ycenter +' halflen -' q2) (x2 +' t1, ycenter +' halflen -' t2)
        |> close-with-line
    in
    let graphics point = [ fill color (path point); ] in
    let widparen = w0 +' w1 +' w2 +' w-extra in
    let kerninfo y =
      let widkern = widparen *' 0.5 in
      let r = 0.25 in
      let gap = length-abs (y -' hgtaxis) in
        let diff = length-min (gap -' halflen *' r) (halflen *' (1. -. r)) in
        if 0pt <' diff then
          widkern *' (diff /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let-math \paren =
    math-paren paren-left paren-right


  let-math \app m1 m2 = ${#m1 \paren{#m2}}


  let brace-left hgt dpt hgtaxis fontsize color =

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let halflen = half-length hgt dpt hgtaxis fontsize in
    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w-straight = h-straight *' 0.15 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = fontsize *' 0.125 in
    let x1 = fontsize *' 0.25 in
    let x2 = x1 -' w-straight in
    let x3 = x2 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x2 +' fontsize *' 0.0625 in
    let x6 = x5 +' w-straight in
    let x7 = fontsize *' 0.225 in

    let p0 = fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x2 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x6 +' w6 in
    let p7 = fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 -' (y2 -' y1) *' ((x1 -' p1) /' (x2 -' x1)) in
    let q2 = y2 +' (y2 -' y1) *' ((p2 -' x2) /' (x2 -' x1)) in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 +' (y5 -' y6) *' ((p5 -' x5) /' (x5 -' x6)) in
    let q6 = y6 -' (y5 -' y6) *' ((x6 -' p6) /' (x5 -' x6)) in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x, ycenter +' y) in
      let fN (x, y) = (xpos +' x, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x2, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x6, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x6, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x2, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    let graphics point = [ fill color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics (x4 +' w-extra) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let brace-right hgt dpt hgtaxis fontsize color =

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let halflen = half-length hgt dpt hgtaxis fontsize in
    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w-straight = h-straight *' 0.15 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = w-extra +' fontsize *' 0.125 in
    let x1 = w-extra +' fontsize *' 0.25 in
    let x2 = x1 -' w-straight in
    let x3 = x2 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x2 +' fontsize *' 0.0625 in
    let x6 = x5 +' w-straight in
    let x7 = w-extra +' fontsize *' 0.225 in

    let p0 = w-extra +' fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x2 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x6 +' w6 in
    let p7 = w-extra +' fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 -' (y2 -' y1) *' ((x1 -' p1) /' (x2 -' x1)) in
    let q2 = y2 +' (y2 -' y1) *' ((p2 -' x2) /' (x2 -' x1)) in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 +' (y5 -' y6) *' ((p5 -' x5) /' (x5 -' x6)) in
    let q6 = y6 -' (y5 -' y6) *' ((x6 -' p6) /' (x5 -' x6)) in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x4 -' x +' w-extra, ycenter +' y) in
      let fN (x, y) = (xpos +' x4 -' x +' w-extra, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x2, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x6, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x6, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x2, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    let graphics point = [ fill color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics x4 (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let brace-left-long hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in

    let t0B = fontsize *' 0.05 in
    let t1A = fontsize *' 0.05 in
    let t1B = fontsize *' 0.025 in
    let t2A = halflen *' 0.1 in
    let t2B = halflen *' 0.15 in
    let t3A = fontsize *' 0.05 in

    let (x0, y0) = (fontsize *' 0.005, fontsize *' 0.005) in
    let (p0B, q0B) = (x0 +' t0B, y0) in

    let (x1, y1) = (fontsize *' 0.2, fontsize *' 0.2) in
    let (p1A, q1A) = (x1, y1 -' t1A) in
    let (p1B, q1B) = (x1, y1 +' t1B) in

    let theta = atan2 (x1 /' 1pt) (halflen /' 1pt) in

    let (x2, y2) = (fontsize *' 0.175, halflen *' 0.5) in

    let (p2A, q2A) = (x2 +' t2A *' (sin theta), y2 -' t2A *' (cos theta)) in
    let (p2B, q2B) = (x2 -' t2B *' (sin theta), y2 +' t2B *' (cos theta)) in

    let (x3, y3) = (fontsize *' 0.15, halflen -' fontsize *' 0.2) in

    let (p3A, q3A) = (x3, y3 -' t3A) in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x, ycenter +' y) in
      let fN (x, y) = (xpos +' x, ycenter -' y) in
%        start-path (fP (x0, y0))
%          |> bezier-to (fP (p0B, q0B)) (fP (p1A, q1A)) (fP (x1, y1))
%          |> bezier-to (fP (p1B, q1B)) (fP (p2A, q2A)) (fP (x2, y2))
%          |> close-with-line
        Gr.poly-line (fP (x0, y0)) [
          fP (p0B, q0B); fP (p1A, q1A); fP (x1, y1);
          fP (p1B, q1B); fP (p2A, q2A); fP (x2, y2);
          fP (p2B, q2B); fP (p3A, q3A); fP (x3, y3);
        ]
    in
    let graphics point = [ fill color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics (x2) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let-math \brace =
    math-paren brace-left brace-right


  let bar-middle hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let halfwid = fontsize *' 0.5 in
    let graphics (x, y) =
      [ stroke 0.5pt color (Gr.line (x +' halfwid, y +' hgtaxis -' halflen) (x +' halfwid, y +' hgtaxis +' halflen)); ]
    in
    let kerninfo _ = 0pt in
      (inline-graphics (halfwid *' 2.) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let-math \setsep m1 m2 =
    math-paren-with-middle brace-left brace-right bar-middle [m1; m2]


  let slash-middle hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let halfwid = halflen *' 0.5 in
    let graphics (x, y) =
      [ stroke 0.5pt color (Gr.line (x, y +' hgtaxis -' halflen) (x +' halfwid *' 2., y +' hgtaxis +' halflen)); ]
    in
    let kerninfo _ = 0pt in
      (inline-graphics (halfwid *' 2.) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let bracket-metrics fontsize halflen =
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.05 +' halflen *' 0.005 in
    let w2 = halflen *' 0.3 in
    let t = fontsize *' 0.03 in
      (w0, w1, w2, t)


  let bracket-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x2, ytop)
        |> line-to (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x2, ybot)
        |> line-to (x2, ybot +' t)
        |> line-to (x1, ybot +' t)
        |> line-to (x1, ytop -' t)
        |> line-to (x2, ytop -' t)
        |> close-with-line


  let floor-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x2, ybot)
        |> line-to (x2, ybot +' t)
        |> line-to (x1, ybot +' t)
        |> line-to (x1, ytop)
        |> close-with-line


  let ceil-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x2, ytop)
        |> line-to (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x1, ybot)
        |> line-to (x1, ytop -' t)
        |> line-to (x2, ytop -' t)
        |> close-with-line


  let bracket-left pathf hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let (w0, w1, w2, t) = bracket-metrics fontsize halflen in
    let path (xpos, ypos) =
      let x0 = xpos +' w0 in
      let x1 = x0 +' w1 in
      let x2 = x1 +' w2 in
        pathf x0 x1 x2 t ypos hgtaxis halflen
    in
    let graphics point = [ fill color (path point); ] in
    let widparen = w0 +' w1 +' w2 in
      (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, (fun _ -> 0pt))


  let bracket-right pathf hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let (w0, w1, w2, t) = bracket-metrics fontsize halflen in
    let widparen = w0 +' w1 +' w2 in
    let path (xpos, ypos) =
      let x0 = xpos +' widparen -' w0 in
      let x1 = x0 -' w1 in
      let x2 = x1 -' w2 in
        pathf x0 x1 x2 t ypos hgtaxis halflen
    in
    let graphics point = [ fill color (path point); ] in
      (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, (fun _ -> 0pt))


  let sqbracket-left = bracket-left bracket-path
  let sqbracket-right = bracket-right bracket-path
  let-math \sqbracket =
    math-paren sqbracket-left sqbracket-right


  let floor-left = bracket-left floor-path
  let floor-right = bracket-right floor-path
  let-math \floor =
    math-paren floor-left floor-right


  let ceil-left = bracket-left ceil-path
  let ceil-right = bracket-right ceil-path
  let-math \ceil =
    math-paren ceil-left ceil-right


  let empty-paren _ _ _ _ _ = (inline-nil, (fun _ -> 0pt))


  let abs-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 5.0pt in
    let path (xpos, ypos) =
      start-path (xpos +' wid *' 0.5, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid *' 0.5, ypos +' hgtaxis -' halflen)
        |> close-with-line
    in
    let graphics point = [ stroke 0.5pt color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let abs-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 5.0pt in
    let path (xpos, ypos) =
      start-path (xpos +' wid *' 0.5, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid *' 0.5, ypos +' hgtaxis -' halflen)
        |> close-with-line
    in
    let graphics point = [ stroke 0.5pt color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let-math \abs =
    math-paren abs-left abs-right


  let norm-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 7.0pt in
    let path (xpos, ypos) =
      unite-path (
        start-path (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      ) (
        start-path (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      )
    in
    let graphics point = [ stroke 0.5pt color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let norm-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 7.0pt in
    let path (xpos, ypos) =
      unite-path (
        start-path (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      ) (
        start-path (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      )
    in
    let graphics point = [ stroke 0.5pt color (path point); ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  let-math \norm =
    math-paren norm-left norm-right


  let-math \set m =
    ${\brace{#m}}


  let-math \cases lst =
    let m-inner =
      text-in-math MathInner (fun ctx -> (
        let size = get-font-size ctx in
        let pads = (0pt, 0pt, size *' 0.25, size *' 0.25) in
        let celllstlst =
          lst |> List.map (fun (m, it) -> (
            let ib1 = embed-math ctx m ++ inline-fil in
            let ib2 = inline-skip size ++ read-inline ctx it ++ inline-fil in
              [NormalCell(pads, ib1); NormalCell(pads, ib2)]
          ))
        in
        let ib = tabular celllstlst (fun _ _ -> []) in
        let (_, hgt, dpt) = get-natural-metrics ib in
        let hgtaxis = get-axis-height ctx in
          raise-inline (hgtaxis -' (hgt +' dpt) *' 0.5) ib

      ))
    in
      math-paren brace-left empty-paren m-inner


end