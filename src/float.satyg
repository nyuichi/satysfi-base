use Eq
use Ord
use String
use Char
use Int
use List

module Float :> sig
  val persistent ~inf : float
  val persistent ~ninf : float
  val persistent ~nan : float

  val persistent ~is-zero : float -> bool
  val persistent ~is-inf : float -> bool
  val persistent ~is-nan : float -> bool
  val persistent ~is-subnormal : float -> bool
  val persistent ~is-normal : float -> bool
  val persistent ~signbit : float -> bool
  val persistent ~ldexp : int -> float -> float
  val persistent ~frexp : float -> float * int

  val persistent ~(<) : float -> float -> bool
  val persistent ~(>) : float -> float -> bool
  val persistent ~(>=) : float -> float -> bool
  val persistent ~(<=) : float -> float -> bool
  val persistent ~(==) : float -> float -> bool  % ieee754-compliant comparison

  % only defined for non-nan values
  val persistent ~ord : implicit (Ord.t float)
  val persistent ~eq : implicit (Eq.t float)

  val persistent ~equal : float -> float -> bool

  val persistent ~neg : float -> float
  val persistent ~abs : float -> float
  val persistent ~min : float -> float -> float
  val persistent ~max : float -> float -> float
  val persistent ~min-value : float % == neg-inf
  val persistent ~max-value : float % == inf
  val persistent ~pow : float -> float -> float

  val persistent ~of-int : int -> float
  val persistent ~to-int : float -> int
  val persistent ~of-string-opt : string -> float option
  val persistent ~to-string : float -> string

  val persistent ~ceil : float -> float
  val persistent ~floor : float -> float
  val persistent ~round : float -> float
  val persistent ~truncate : float -> float

  val persistent ~sin : float -> float
  val persistent ~cos : float -> float
  val persistent ~tan : float -> float
  val persistent ~asin : float -> float
  val persistent ~acos : float -> float
  val persistent ~atan : float -> float
  val persistent ~atan2 : float -> float -> float
  val persistent ~sqrt : float -> float
  val persistent ~exp : float -> float
  val persistent ~log : float -> float
  val persistent ~log10 : float -> float

  val persistent ~pi : float
  val persistent ~e : float
end = struct
  val persistent ~neg f = (0.0 -. 1.0) *. f % `0.0 -. f` does not work properly when f == 0.0

  val persistent ~nan = 0.0 /. 0.0
  val persistent ~inf = 1.0 /. 0.0
  val persistent ~ninf = neg inf

  val persistent ~to-length f = 1pt *' f % never introduces inexactness

  val persistent ~exp2i i =
    if i < -1074 then
      0.0
    else if i > 1023 then
      inf
    else
      % binary method
      let rec aux i e acc =
        if i == 0 then
          acc
        else
          aux (i / 2) (e *. e) (if i mod 2 == 1 then acc *. e else acc) in
      if i >= 0 then
        aux i 2.0 1.0
      else
        aux (-i) 0.5 1.0

  val persistent ~(<) f g = to-length f <' to-length g
  val persistent ~(>) f g = g < f

  val persistent ~abs f = if f < 0.0 then neg f else f

  val persistent ~is-zero-or-nan f = not (f < neg f || f > neg f)
  val persistent ~is-nan f = is-zero-or-nan f && is-zero-or-nan (f +. 1.0)
  val persistent ~is-zero f = is-zero-or-nan f && not (is-nan f)
  val persistent ~is-inf f = not (is-nan f) && is-nan (f -. f)
  val persistent ~(==) f g =
    if is-nan f || is-nan g then
      false
    else if is-inf f || is-inf g then
      (is-inf f && is-inf g && f *. g > 0.0)
    else
      is-zero (f -. g)
  val persistent ~(<=) f g = f < g || f == g
  val persistent ~(>=) f g = g <= f

  val persistent ~is-finite f = not (is-nan f || is-inf f)
  val persistent ~min-normal = exp2i(-1022)
  val persistent ~is-subnormal f = is-finite f && not (is-zero f) && f < min-normal
  val persistent ~is-normal f = is-finite f && not (is-zero f) && f >= min-normal

  val persistent ~ord = Ord.make (fun a b -> (if a < b then Lt else if a > b then Gt else Eq))
  val persistent ~eq = Ord.derive-eq ord

  val persistent ~equal = Eq.equal eq

  val persistent ~min f g = if is-nan f || is-nan g then nan else if f < g then f else g
  val persistent ~max f g = if is-nan f || is-nan g then nan else if f > g then f else g

  val persistent ~min-value = ninf
  val persistent ~max-value = inf

  val persistent ~of-int = float
  val persistent ~to-int = round

  val persistent ~of-string-opt str =
    let dot = Char.make `.` in
    let (first-str, second-str-opt) = String.split-by-first dot str in
    let second-str =
      match second-str-opt with
      | Some(s) -> s
      | None -> `0`
      end
    in
    let first-int-opt = Int.of-string-opt first-str in
    let second-int-opt = Int.of-string-opt second-str in
    let second-str-len = String.length second-str in
    let rec make-ten n m =
      if Int.(n <= 0) then
        m
      else
        make-ten (n - 1) (m * 10)
    in
      match (first-int-opt,second-int-opt) with
      | (Some(n1),Some(n2)) ->
        if Int.(n2 < 0) then
          None
        else
          Some(
            if Int.(n1 >= 0) then
              (of-int n1) +. ((of-int n2) /. (make-ten second-str-len 1 |> of-int))
            else
              (of-int n1) -. ((of-int n2) /. (make-ten second-str-len 1 |> of-int))
          )
      | _ -> None
      end
  val persistent ~to-string = show-float

  val persistent ~signbit f =
    if is-nan f then
      false
    else if is-zero f then
      (1.0 /. f) < 0.0
    else
      (f < 0.0)

  val persistent ~get-exp-fixture = [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]

  val persistent ~get-exp f =
    if not (is-finite f) then
      2047
    else if is-zero f || is-subnormal f then
      0
    else
      let f = abs f in
      % exponent ranges over [1,2046]
      % exp = exponent - 1023
      get-exp-fixture |> List.fold 0 (fun inc exponent -> (
        if f >= exp2i (exponent + inc - 1023) then
          exponent + inc
        else
          exponent
      ))

  val persistent ~rec frexp f = % never invokes rounding
    if is-nan f || is-inf f then
      (f, 1023)
    else if is-zero f then
      (f, 0)
    else if f < 0.0 then
      let (f, exp) = frexp (neg f) in
      (neg f, exp)
    else if is-subnormal f then
      let rec aux f e = % adjust subnormal numbers
        if f >= 0.5 then
          (f, e)
        else
          aux (f *. 2.0) (e - 1)
      in
      aux f 0
    else
      let exp = get-exp f - 1023 in
      (f *. exp2i (- exp), exp)

  val persistent ~rec ldexp exp f =
    let open Int in
    if is-nan f || is-inf f || is-zero f || exp == 0 then
      f
    else if exp >= 0 then
      if exp <= 1023 then
        f *. exp2i exp
      else
        ldexp (exp - 1023) (f *. exp2i 1023)
    else
      if exp >= -1074 then
        f *. exp2i exp
      else
        let (f, e) = frexp f in
        f *. exp2i (e + exp)

  % round towards zero
  val persistent ~rec truncate f =
    if not (is-finite f) then
      f
    else if is-zero f then
      f
    else
      let (_, e) = frexp f in
      if Int.(e >= 52) then
        f
      else
        of-int (to-int f)

  % round towards nearest; halfway cases rounded away from zero
  val persistent ~rec round f =
    if not (is-finite f) then
      f
    else if is-zero f then
      f
    else
      let g = truncate f in
      if f > 0.0 then
        if (f -. g) >= 0.5 then
          g +. 1.0
        else
          g
      else
        if (g -. f) >= 0.5 then
          g -. 1.0
        else
          g

  val persistent ~ceil f =
    if not (is-finite f) then
      f
    else if is-zero f then
      f
    else if f < 0.0 then
      truncate f
    else
      let g = truncate f in
      if g == f then
        g
      else
        g +. 1.0

  val persistent ~floor f =
    if not (is-finite f) then
      f
    else if is-zero f then
      f
    else if f > 0.0 then
      truncate f
    else
      let g = truncate f in
      if g == f then
        g
      else
        g -. 1.0

  val persistent ~sin = sin
  val persistent ~cos = cos
  val persistent ~tan = tan
  val persistent ~asin = asin
  val persistent ~acos = acos
  val persistent ~atan = atan
  val persistent ~atan2 = atan2
  val persistent ~exp = exp
  val persistent ~log = log
  val persistent ~log10- = log 10.0
  val persistent ~log10 x = log x /. log10-

  val persistent ~pow y x = exp (y *. log x) % x^y == (x |> pow y)
  val persistent ~sqrt = pow 0.5

  val persistent ~pi = atan2 0.0 (neg 1.0)
  val persistent ~e = exp 1.0
end
