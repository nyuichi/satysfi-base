use open Util
use List
use Char
use Ord
use Eq

module String :> sig
  val persistent ~equal : string -> string -> bool
  val persistent ~ord : implicit (Ord.t string)
  val persistent ~eq : implicit (Eq.t string)
  val persistent ~max : string -> string -> string
  val persistent ~min : string -> string -> string
  val persistent ~(<) : string -> string -> bool
  val persistent ~(>) : string -> string -> bool
  val persistent ~(>=) : string -> string -> bool
  val persistent ~(<=) : string -> string -> bool
  val persistent ~(==) : string -> string -> bool
  val persistent ~length : string -> int
  val persistent ~sub : int -> int -> string -> string
  val persistent ~empty : string
  val persistent ~of-bool : bool -> string
  val persistent ~of-int : int -> string
  val persistent ~of-float : float -> string
  val persistent ~of-codepoints : list int -> string
  val persistent ~of-char : Char.t -> string
  val persistent ~of-length : length -> string
  val persistent ~append : string -> string -> string
  val persistent ~concat : list string -> string
  val persistent ~is-empty : string -> bool
  val persistent ~starts-with : string -> string -> bool
  val persistent ~ends-with : string -> string -> bool
  val persistent ~to-list : string -> list Char.t
  val persistent ~of-list : list Char.t -> string
  val persistent ~pow : int -> string -> string
  val persistent ~split : int -> string -> string * string
  val persistent ~split-by-first : Char.t -> string -> string * option string
  val persistent ~split-by : Char.t -> string -> list string
  val persistent ~lines : string -> list string
  val persistent ~index : Char.t -> string -> option int
  % val byte-length : string -> int
  % val sub-bytes : int -> int -> string -> string
end = struct
  val persistent ~equal = string-same
  val persistent ~eq = Eq.make equal
  val persistent ~length = string-length
  val persistent ~sub i l s = string-sub s i l
  val persistent ~of-bool b = if b then `true` else `false`
  val persistent ~of-int = arabic
  val persistent ~of-float = show-float
  val persistent ~empty = ` `
  val persistent ~of-codepoints = string-unexplode
  val persistent ~of-char = Char.to-string
  val persistent ~append s1 s2 = s1 ^ s2

  val persistent ~rec concat xs =
    match xs with
    | [] -> empty
    | s :: xs -> s ^ concat xs
    end

  val persistent ~is-empty s =
    equal s empty

  val persistent ~starts-with p s =
    let s-len = length s in
    let p-len = length p in
    (s-len >= p-len) &&&- (fun () -> equal (s |> sub 0 p-len) p)

  val persistent ~ends-with p s =
    let s-len = length s in
    let p-len = length p in
    (s-len >= p-len) &&&- (fun () -> equal (s |> sub (s-len - 1 - p-len) p-len) p)

  val persistent ~to-list s =
    let rec go i acc =
      match i with
      | 0 -> acc
      | _ -> go (i - 1) (Char.at (i - 1) s :: acc)
      end
    in
    go (length s) []

  val persistent ~of-list chars =
    chars |> List.map Char.to-string |> concat

  val persistent ~pow n s =
    let rec go i acc = if i == n then acc else go (i + 1) (acc ^ s) in
    go 0 empty

  val persistent ~split i s =
    (sub 0 i s, sub i (length s - i) s)

  val persistent ~split-by-first d s =
    let rec aux maxlen len =
      if len >= maxlen then
        (s, None)
      else if Char.equal (Char.at len s) d then
        (sub 0 len s, Some(sub (len + 1) (maxlen - len - 1) s))
      else
        aux maxlen (len + 1)
    in aux (length s) 0

  val persistent ~rec split-by d s =
    match split-by-first d s with
    | (head, Some(tail)) -> head :: split-by d tail
    | (head, None)       -> [head]
    end

  val persistent ~lines = split-by Char.newline

  val persistent ~index c s =
    let cs = to-list s in
    let rec aux cs acc =
      match cs with
      | [] -> None
      | (x::xs) -> if Eq.equal Char.eq c x then Some(acc) else aux xs (acc + 1)
      end
    in aux cs 0

  val persistent ~of-length l =
    % -- the following are mostly copied from `ZL0.string-of-length` in `zrbase/zl0`
    let xs = show-float (l /' 1pt) in
    let pu = string-length xs - 1 in
    if string-same (string-sub xs pu 1) `.` then
      string-sub xs 0 pu ^ `pt`
    else xs ^ `pt`
    % -- end

  val persistent ~ord =
    Ord.make (fun sl sr -> (
      let lstl = string-explode sl in
      let lstr = string-explode sr in
      let rec sub lstl lstr =
          match (lstl, lstr) with
          | ([],[]) -> Ord.Eq
          | (_, []) -> Ord.Gt
          | ([],_) -> Ord.Lt
          | (nl::xl,nr::xr) ->
              if nl < nr then
                  Ord.Lt
              else
                  if nl > nr then
                      Ord.Gt
                  else
                      sub xl xr
          end
      in
      sub lstl lstr
    ))
  val persistent ~max = Ord.max ord
  val persistent ~min = Ord.min ord
  val persistent ~(<) = Ord.lt ord
  val persistent ~(>) = Ord.gt ord
  val persistent ~(>=) = Ord.ge ord
  val persistent ~(<=) = Ord.le ord
  val persistent ~(==) = Ord.eq ord



  % let byte-length = string-byte-length
  % let sub-bytes i j s = string-sub-bytes s i j
end
