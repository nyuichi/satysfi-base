use open Util
use Fn

module Result :> sig
  val persistent ~ok 'a 'e : 'a -> result 'a 'e
  val persistent ~err 'a 'e : 'e -> result 'a 'e
  val persistent ~is-ok 'a 'e : result 'a 'e -> bool
  val persistent ~is-err 'a 'e : result 'a 'e -> bool
  val persistent ~to-ok 'a 'e : result 'a 'e -> option 'a
  val persistent ~to-err 'a 'e : result 'a 'e -> option 'e
  val persistent ~unwrap 'a 'e : result 'a 'e -> 'a
  val persistent ~unwrap-or 'a 'e : 'a -> result 'a 'e -> 'a
  val persistent ~unwrap-or-else 'a 'e : ('e -> 'a) -> result 'a 'e -> 'a
  val persistent ~unwrap-err 'a 'e : result 'a 'e -> 'e
  val persistent ~expect 'a 'e : string -> result 'a 'e -> 'a
  val persistent ~expect-err 'a 'e : string -> result 'a 'e -> 'e
  val persistent ~map 'a 'b 'e : ('a -> 'b) -> result 'a 'e -> result 'b 'e
  val persistent ~map-or 'a 'b 'e : 'b -> ('a -> 'b) -> result 'a 'e -> 'b
  val persistent ~map-or-else 'a 'b 'e : ('e -> 'b) -> ('a -> 'b) -> result 'a 'e -> 'b
  val persistent ~map-err 'a 'e 'f : ('e -> 'f) -> result 'a 'e -> result 'a 'f
  val persistent ~and- 'a 'e : result 'a 'e -> result 'a 'e -> result 'a 'e
  val persistent ~and-then 'a 'b 'e : ('a -> result 'b 'e) -> result 'a 'e -> result 'b 'e
  val persistent ~or 'a 'e : result 'a 'e -> result 'a 'e -> result 'a 'e
  val persistent ~or-else 'a 'e 'f : ('e -> result 'a 'f) -> result 'a 'e -> result 'a 'f
  val persistent ~transpose 'a 'e : result (option 'a) 'e -> option (result 'a 'e)
  val persistent ~flatten 'a 'e : result (result 'a 'e) 'e -> result 'a 'e
  val persistent ~ret 'a 'e : 'a -> result 'a 'e
  val persistent ~fold-list 'a 'b 'e : list 'a -> ('a -> 'b -> result 'b 'e) -> 'b -> result 'b 'e

  % deprecated
  val persistent ~bind 'a 'b 'e : ('a -> result 'b 'e) -> result 'a 'e -> result 'b 'e
  val persistent ~join 'a 'e : result (result 'a 'e) 'e -> result 'a 'e
  val persistent ~to-option 'a 'e : result 'a 'e -> option 'a
end = struct
  val persistent ~ok x = Ok x
  val persistent ~err e = Err e

  val persistent ~is-ok r =
    match r with
    | Ok(_) -> true
    | _ -> false
    end

  val persistent ~is-err r =
    match r with
    | Ok(_) -> false
    | _ -> true
    end

  val persistent ~to-ok r =
    match r with
    | Ok(a) -> Some(a)
    | _ -> None
    end

  val persistent ~to-err r =
    match r with
    | Err(e) -> Some(e)
    | _ -> None
    end

  val persistent ~unwrap-or-else f r =
    match r with
    | Ok(a) -> a
    | Err(e) -> f e
    end

  val persistent ~expect msg r =
    r |> unwrap-or-else (fun _ -> panic msg)

  val persistent ~expect-err msg r =
    match r with
    | Ok(a) -> panic msg
    | Err(e) -> e
    end

  val persistent ~unwrap r =
    r |> expect `unwrap error`

  val persistent ~unwrap-or x r =
    r |> unwrap-or-else (Fn.const x)

  val persistent ~unwrap-err r =
    r |> expect-err `unwrap error`

  val persistent ~map f r =
    match r with
    | Ok(a) -> ok (f a)
    | Err(e) -> err e
    end

  val persistent ~map-or b f r =
    match r with
    | Ok(a) -> f a
    | Err(e) -> b
    end

  val persistent ~map-or-else g f r =
    match r with
    | Ok(a) -> f a
    | Err(e) -> g e
    end

  val persistent ~map-err f r =
    match r with
    | Ok(a) -> ok a
    | Err(e) -> err (f e)
    end

  val persistent ~rec and- r1 r2 =
    match r2 with
    | Err(_) -> r2
    | _ -> r1
    end

  val persistent ~and-then k r =
    match r with
    | Ok(a) -> k a
    | Err(e) -> err e
    end

  val persistent ~rec or r1 r2 =
    match r2 with
    | Ok(_) -> r2
    | _ -> r1
    end

  val persistent ~rec or-else f r =
    match r with
    | Ok(a) -> ok a
    | Err(e) -> f e
    end

  val persistent ~transpose r =
    match r with
    | Ok(Some(x)) -> Some(ok x)
    | Ok(None)    -> None
    | Err(e)      -> Some(err e)
    end

  val persistent ~ret x = ok x

  val persistent ~flatten r =
    match r with
    | Ok(r) -> r
    | Err(e) -> err e
    end

  val persistent ~rec fold-list list f init =
    match list with
    | [] -> init |> ret
    | x :: xs -> init |> f x |> and-then (fold-list xs f)
    end

  val persistent ~bind = and-then
  val persistent ~join = flatten
  val persistent ~to-option = to-ok
end