use Float

module Length :> sig
  val of-pt : float -> length
  val of-cm : float -> length
  val of-mm : float -> length
  val of-in : float -> length
  val to-float : length -> float

  val add : length -> length -> length
  val sub : length -> length -> length
  val scale : float -> length -> length  % e.g. 2pt |> scale 2.0 == 4pt
  val ratio : length -> length -> float  % e.g. 6pt |> ratio 2pt == 3.0

  val (<) : length -> length -> bool
  val (>) : length -> length -> bool
  val (>=) : length -> length -> bool
  val (<=) : length -> length -> bool
  val (==) : length -> length -> bool

  val equal : length -> length -> bool

  val min : length -> length -> length
  val max : length -> length -> length
  val neg : length -> length
  val abs : length -> length
end = struct
  val of-pt f = 1pt *' f % no conversion occurs internally
  val of-cm f = 1cm *' f
  val of-mm f = 1mm *' f
  val of-in f = 1inch *' f
  val to-float l = l /' 1pt

  val add l m = l +' m
  val sub l m = l -' m
  val scale f l = l *' f
  val ratio l m = m /' l

  val (<) l m = Float.(to-float l < to-float m)
  val (>) l m = Float.(to-float l > to-float m)
  val (<=) l m = Float.(to-float l <= to-float m)
  val (>=) l m = Float.(to-float l >= to-float m)
  val (==) l m = Float.(to-float l == to-float m)

  val equal l m = l == m

  % REQUIRE(!is-nan(f) && !is-nan(g))
  val min f g = if f < g then f else g
  val max f g = if f > g then f else g
  val neg f = scale (0.0 -. 1.0) f
  val abs f = if f < 0.0pt then neg f else f
end