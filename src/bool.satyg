use open Util
use Ord
use Eq
use Float

module Bool :> sig
  val persistent ~ord : implicit (Ord.t bool)
  val persistent ~eq : implicit (Eq.t bool)

  val persistent ~equal : bool -> bool -> bool

  val persistent ~(<) : bool -> bool -> bool
  val persistent ~(>) : bool -> bool -> bool
  val persistent ~(>=) : bool -> bool -> bool
  val persistent ~(<=) : bool -> bool -> bool
  val persistent ~(==) : bool -> bool -> bool

  val persistent ~max : bool -> bool -> bool
  val persistent ~min : bool -> bool -> bool
  val persistent ~max-value : bool
  val persistent ~min-value : bool

  val persistent ~to-int : bool -> int
  val persistent ~of-int-opt : int -> option bool
  val persistent ~to-string : bool -> string
  val persistent ~of-string-opt : string -> option bool

end = struct
  val persistent ~ord = Ord.make (fun b1 b2 -> (
    match (b1, b2) with
    | (true, true) -> Ord.Eq
    | (false, false) -> Ord.Eq
    | (true, false) -> Ord.Gt
    | (false, true) -> Ord.Lt
    end
  ))

  val persistent ~max = ( || )
  val persistent ~min = ( && )
  val persistent ~max-value = true
  val persistent ~min-value = false

  val persistent ~eq = Ord.derive-eq ord
  val persistent ~equal = Eq.equal eq

  val persistent ~(<) = Ord.lt ord
  val persistent ~(>) = Ord.gt ord
  val persistent ~(>=) = Ord.ge ord
  val persistent ~(<=) = Ord.le ord
  val persistent ~(==) = Ord.eq ord

  val persistent ~to-int b = if b then 1 else 0
  val persistent ~of-int-opt n =
    match n with
    | 0 -> Some(false)
    | 1 -> Some(true)
    | _ -> None
    end
  val persistent ~to-string b = if b then `true` else `false`
  val persistent ~of-string-opt str =
    match str with
    | `true`  -> Some(true)
    | `false` -> Some(false)
    | _       -> None
    end

end