use open Util
use Eq

% total order on 'a

module Ord :> sig
  type ordering = Lt | Gt | Eq
  type t :: o -> o
  val persistent ~make 'a : ('a -> 'a -> ordering) -> t 'a
  val persistent ~compare 'a : implicit (t 'a) -> 'a -> 'a -> ordering
  val persistent ~min 'a : implicit (t 'a) -> 'a -> 'a -> 'a
  val persistent ~max 'a : implicit (t 'a) -> 'a -> 'a -> 'a
  val persistent ~eq 'a : implicit (t 'a) -> 'a -> 'a -> bool
  val persistent ~lt 'a : implicit (t 'a) -> 'a -> 'a -> bool
  val persistent ~le 'a : implicit (t 'a) -> 'a -> 'a -> bool
  val persistent ~gt 'a : implicit (t 'a) -> 'a -> 'a -> bool
  val persistent ~ge 'a : implicit (t 'a) -> 'a -> 'a -> bool
  val persistent ~derive-eq 'a : implicit (t 'a) -> implicit (Eq.t 'a)
end = struct
  type ordering = Lt | Gt | Eq

  type t 'a = 'a -> 'a -> ordering

  val persistent ~make ord = ord

  val persistent ~compare ord = ord

  val persistent ~eq ord a b =
    match compare ord a b with
    | Eq -> true
    | _ -> false
    end

  val persistent ~lt ord a b =
    match compare ord a b with
    | Lt -> true
    | _ -> false
    end

  val persistent ~le ord a b =
    match compare ord a b with
    | Lt -> true
    | Eq -> true
    | _ -> false
    end

  val persistent ~gt ord a b =
    match compare ord a b with
    | Gt -> true
    | _ -> false
    end

  val persistent ~ge ord a b =
    match compare ord a b with
    | Gt -> true
    | Eq -> true
    | _ -> false
    end

  val persistent ~min ord a b =
    if le ord a b then
      a
    else
      b

  val persistent ~max ord a b =
    if ge ord a b then
      a
    else
      b

  val persistent ~derive-eq ord = Eq.make (eq ord)
end
