use Set
use List
use Fn
use Tuple

% immutable map
%
% In [Kunen, 2011], a _function_ is defined to be a set of ordered pairs such that
% no two ordered pairs share the same object in their first position.
% So, technically, what the following module implements is _function_.

module Map :> sig
  type t :: o -> o -> o
  val persistent ~empty 'k 'v : t 'k 'v
  val persistent ~is-empty 'k 'v : t 'k 'v -> bool
  val persistent ~size 'k 'v : t 'k 'v -> int
  val persistent ~of- : implicit (Eq.t 'k) -> 'k -> t 'k 'v -> option 'v
  val persistent ~bind : 'k -> 'v -> t 'k 'v -> t 'k 'v
  val persistent ~unbind : implicit (Eq.t 'k) -> 'k -> t 'k 'v -> t 'k 'v
  val persistent ~dom : implicit (Eq.t 'k) -> t 'k 'v -> list 'k
  val persistent ~ran : implicit (Eq.t 'k) -> t 'k 'v -> list 'v
  val persistent ~of-list : list ('k * 'v) -> t 'k 'v
  val persistent ~to-list : implicit (Eq.t 'k) -> t 'k 'v -> list ('k * 'v)
end = struct
  type t 'k 'v = Set.t ('k * 'v)

  val persistent ~size m = Set.size m

  val persistent ~empty = Set.empty

  val persistent ~is-empty m = Set.is-empty m

  val persistent ~key-eq eq =
    Eq.make (Eq.equal eq |> Fn.on Pair.fst)

  val persistent ~of- eq k m =
    match Set.choose m with
    | None -> None
    | Some(_, v) ->
      match m |> Set.mem-opt (key-eq eq) (k, v) with
      | None -> None
      | Some(_, v) -> Some(v)
      end
    end

  val persistent ~bind k v m = Set.insert (k, v) m

  val persistent ~unbind eq k m =
    match Set.choose m with
    | None -> m
    | Some(_, v) -> Set.remove (key-eq eq) (k, v) m
    end

  val persistent ~dom eq m = m |> Set.to-list (key-eq eq) |> List.map Pair.fst

  val persistent ~ran eq m = m |> Set.to-list (key-eq eq) |> List.map Pair.snd

  val persistent ~of-list alist =
    let rec aux alist =
      match alist with
      | [] -> empty
      | (k, v) :: alist -> bind k v (aux alist)
      end
    in aux (List.reverse alist)

  val persistent ~to-list eq m = Set.to-list (key-eq eq) m
end
