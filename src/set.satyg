use Util
use List
use Eq

% This module implements pre-set-like structure

module Set :> sig
  type t :: o -> o
  val persistent ~empty 'a : t 'a
  val persistent ~singleton 'a : 'a -> t 'a
  val persistent ~size 'a : t 'a -> int
  val persistent ~is-empty 'a : t 'a -> bool
  val persistent ~choose 'a : t 'a -> option 'a
  val persistent ~mem 'a : implicit (Eq.t 'a) -> 'a -> t 'a -> bool
  val persistent ~insert 'a : 'a -> t 'a -> t 'a
  val persistent ~remove 'a : implicit (Eq.t 'a) -> 'a -> t 'a -> t 'a
  val persistent ~of-list 'a : list 'a -> t 'a
  val persistent ~to-list 'a : implicit (Eq.t 'a) -> t 'a -> list 'a
  val persistent ~mem-opt 'a : implicit (Eq.t 'a) -> 'a -> t 'a -> option 'a
end = struct
  type t 'a = list 'a

  val persistent ~empty = []

  val persistent ~singleton v = [v]

  val persistent ~size l = List.length l

  val persistent ~is-empty l = List.null l

  val persistent ~choose l =
    match l with
    | [] -> None
    | v :: _ -> Some(v)
    end

  val persistent ~mem eq v l = List.exists (Eq.equal eq v) l

  val persistent ~insert v l = v :: l

  val persistent ~remove eq v l = List.filter (Eq.inequal eq v) l

  val persistent ~of-list l = l

  val persistent ~to-list eq l =
    let rec dedup l acc =
      match l with
      | [] -> List.reverse acc
      | x :: l ->
          if List.exists (Eq.equal eq x) acc then
            dedup l acc
          else
            dedup l (x :: acc)
      end
    in dedup [] l

  val persistent ~mem-opt eq v l = List.find (Eq.equal eq v) l
end
