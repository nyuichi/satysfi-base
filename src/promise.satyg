use open Util
use Ref

module Promise :> sig
  type t :: o -> o
  val persistent ~make 'a : 'a -> t 'a
  val persistent ~delay 'a : thunk 'a -> t 'a
  val persistent ~delay-force 'a : thunk (t 'a) -> t 'a
  val persistent ~force 'a : t 'a -> 'a
end = struct

  type state 'a =
    | Value of 'a
    | Thunk of thunk (t 'a)
  and t 'a =
    ref (ref (state 'a))

  val persistent ~make v =
    Ref.make (Ref.make (Value v))

  val persistent ~delay-force e =
    Ref.make (Ref.make (Thunk e))

  val persistent ~delay e =
    delay-force (fun () -> make (run-thunk e))

  val persistent ~rec force p =
    match p |> Ref.get |> Ref.get with
    | Value v -> v
    | Thunk f ->
      let q = f () in
      match p |> Ref.get |> Ref.get with % p may be updated during evaluation of q
      | Value v -> v
      | _ ->
        let () = Ref.get p |> Ref.set (Ref.get (Ref.get q)) in
        let () = q |> Ref.set (Ref.get p) in
        force p
      end
    end

end