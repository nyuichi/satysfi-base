use open Util
use List

module Path :> sig
  val start : point -> pre-path
  val line-to : point -> pre-path -> pre-path
  val bezier-to : point -> point -> point -> pre-path -> pre-path
  val terminate : pre-path -> path
  val close-with-line : pre-path -> path
  val close-with-bezier : point -> point -> pre-path -> path
  val bbox : path -> point * point
  val unite : path -> path -> path
  val shift : point -> path -> path
  val line : point -> point -> path
  val poly-line : point -> list point -> path
  val rectangle : point -> point -> path
  val ellipse : point -> length -> length -> path
end = struct
  val start = start-path
  val line-to = line-to
  val bezier-to = bezier-to
  val terminate = terminate-path
  val close-with-line = close-with-line
  val close-with-bezier = close-with-bezier
  val bbox = get-path-bbox
  val unite = unite-path
  val shift = shift-path

  %% copied from `gr.satyh`
  val line pt1 pt2 =
    start-path pt1 |> line-to pt2 |> terminate-path

  %% copied from `gr.satyh`
  val poly-line pt-init pts =
    pts |> List.fold-left (fun acc pt -> (
      acc |> line-to pt
    )) (start-path pt-init) |> terminate-path

  %% copied from `gr.satyh`
  val rectangle (x1, y1) (x2, y2) =
    start-path (x1, y1)
      |> line-to (x1, y2)
      |> line-to (x2, y2)
      |> line-to (x2, y1)
      |> close-with-line

  val ellipse center x-len y-len =
    let sqrt2 = 1.4142135623 in
    let n = ((sqrt2 -. 1.0) *. 4.0) /. 3.0 in
    let minus len = len *' (float (-1)) in
    let zero = 0pt in
    let main =
      start-path (zero, y-len)
      |> bezier-to (x-len *' n, y-len) (x-len, y-len *' n) (x-len, zero)
      |> bezier-to (x-len,  minus (y-len *' n)) (x-len *' n,  minus y-len) (zero,  minus y-len)
      |> bezier-to (minus (x-len *' n), minus y-len) (minus x-len,  minus (y-len *' n)) (minus x-len, zero)
      |> close-with-bezier (minus x-len, y-len *' n) (minus (x-len *' n), y-len)
    in
      shift center main

end
